// Package openhab3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package openhab3

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	originalURL "net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for ConfigDescriptionParameterType.
const (
	ConfigDescriptionParameterTypeBOOLEAN ConfigDescriptionParameterType = "BOOLEAN"

	ConfigDescriptionParameterTypeDECIMAL ConfigDescriptionParameterType = "DECIMAL"

	ConfigDescriptionParameterTypeINTEGER ConfigDescriptionParameterType = "INTEGER"

	ConfigDescriptionParameterTypeTEXT ConfigDescriptionParameterType = "TEXT"
)

// Defines values for ConfigDescriptionParameterDTOType.
const (
	ConfigDescriptionParameterDTOTypeBOOLEAN ConfigDescriptionParameterDTOType = "BOOLEAN"

	ConfigDescriptionParameterDTOTypeDECIMAL ConfigDescriptionParameterDTOType = "DECIMAL"

	ConfigDescriptionParameterDTOTypeINTEGER ConfigDescriptionParameterDTOType = "INTEGER"

	ConfigDescriptionParameterDTOTypeTEXT ConfigDescriptionParameterDTOType = "TEXT"
)

// Defines values for ConfigStatusMessageType.
const (
	ConfigStatusMessageTypeERROR ConfigStatusMessageType = "ERROR"

	ConfigStatusMessageTypeINFORMATION ConfigStatusMessageType = "INFORMATION"

	ConfigStatusMessageTypePENDING ConfigStatusMessageType = "PENDING"

	ConfigStatusMessageTypeWARNING ConfigStatusMessageType = "WARNING"
)

// Defines values for DiscoveryResultDTOFlag.
const (
	DiscoveryResultDTOFlagIGNORED DiscoveryResultDTOFlag = "IGNORED"

	DiscoveryResultDTOFlagNEW DiscoveryResultDTOFlag = "NEW"
)

// Defines values for EnrichedRuleDTOVisibility.
const (
	EnrichedRuleDTOVisibilityEXPERT EnrichedRuleDTOVisibility = "EXPERT"

	EnrichedRuleDTOVisibilityHIDDEN EnrichedRuleDTOVisibility = "HIDDEN"

	EnrichedRuleDTOVisibilityVISIBLE EnrichedRuleDTOVisibility = "VISIBLE"
)

// Defines values for IconSetFormats.
const (
	IconSetFormatsPNG IconSetFormats = "PNG"

	IconSetFormatsSVG IconSetFormats = "SVG"
)

// Defines values for ModuleTypeDTOVisibility.
const (
	ModuleTypeDTOVisibilityEXPERT ModuleTypeDTOVisibility = "EXPERT"

	ModuleTypeDTOVisibilityHIDDEN ModuleTypeDTOVisibility = "HIDDEN"

	ModuleTypeDTOVisibilityVISIBLE ModuleTypeDTOVisibility = "VISIBLE"
)

// Defines values for RuleVisibility.
const (
	RuleVisibilityEXPERT RuleVisibility = "EXPERT"

	RuleVisibilityHIDDEN RuleVisibility = "HIDDEN"

	RuleVisibilityVISIBLE RuleVisibility = "VISIBLE"
)

// Defines values for RuleDTOVisibility.
const (
	RuleDTOVisibilityEXPERT RuleDTOVisibility = "EXPERT"

	RuleDTOVisibilityHIDDEN RuleDTOVisibility = "HIDDEN"

	RuleDTOVisibilityVISIBLE RuleDTOVisibility = "VISIBLE"
)

// Defines values for RuleStatusInfoStatus.
const (
	RuleStatusInfoStatusIDLE RuleStatusInfoStatus = "IDLE"

	RuleStatusInfoStatusINITIALIZING RuleStatusInfoStatus = "INITIALIZING"

	RuleStatusInfoStatusRUNNING RuleStatusInfoStatus = "RUNNING"

	RuleStatusInfoStatusUNINITIALIZED RuleStatusInfoStatus = "UNINITIALIZED"
)

// Defines values for RuleStatusInfoStatusDetail.
const (
	RuleStatusInfoStatusDetailCONFIGURATIONERROR RuleStatusInfoStatusDetail = "CONFIGURATION_ERROR"

	RuleStatusInfoStatusDetailDISABLED RuleStatusInfoStatusDetail = "DISABLED"

	RuleStatusInfoStatusDetailHANDLERINITIALIZINGERROR RuleStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"

	RuleStatusInfoStatusDetailHANDLERMISSINGERROR RuleStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"

	RuleStatusInfoStatusDetailINVALIDRULE RuleStatusInfoStatusDetail = "INVALID_RULE"

	RuleStatusInfoStatusDetailNONE RuleStatusInfoStatusDetail = "NONE"

	RuleStatusInfoStatusDetailTEMPLATEMISSINGERROR RuleStatusInfoStatusDetail = "TEMPLATE_MISSING_ERROR"
)

// Defines values for TemplateVisibility.
const (
	TemplateVisibilityEXPERT TemplateVisibility = "EXPERT"

	TemplateVisibilityHIDDEN TemplateVisibility = "HIDDEN"

	TemplateVisibilityVISIBLE TemplateVisibility = "VISIBLE"
)

// Defines values for ThingStatusInfoStatus.
const (
	ThingStatusInfoStatusINITIALIZING ThingStatusInfoStatus = "INITIALIZING"

	ThingStatusInfoStatusOFFLINE ThingStatusInfoStatus = "OFFLINE"

	ThingStatusInfoStatusONLINE ThingStatusInfoStatus = "ONLINE"

	ThingStatusInfoStatusREMOVED ThingStatusInfoStatus = "REMOVED"

	ThingStatusInfoStatusREMOVING ThingStatusInfoStatus = "REMOVING"

	ThingStatusInfoStatusUNINITIALIZED ThingStatusInfoStatus = "UNINITIALIZED"

	ThingStatusInfoStatusUNKNOWN ThingStatusInfoStatus = "UNKNOWN"
)

// Defines values for ThingStatusInfoStatusDetail.
const (
	ThingStatusInfoStatusDetailBRIDGEOFFLINE ThingStatusInfoStatusDetail = "BRIDGE_OFFLINE"

	ThingStatusInfoStatusDetailBRIDGEUNINITIALIZED ThingStatusInfoStatusDetail = "BRIDGE_UNINITIALIZED"

	ThingStatusInfoStatusDetailCOMMUNICATIONERROR ThingStatusInfoStatusDetail = "COMMUNICATION_ERROR"

	ThingStatusInfoStatusDetailCONFIGURATIONERROR ThingStatusInfoStatusDetail = "CONFIGURATION_ERROR"

	ThingStatusInfoStatusDetailCONFIGURATIONPENDING ThingStatusInfoStatusDetail = "CONFIGURATION_PENDING"

	ThingStatusInfoStatusDetailDISABLED ThingStatusInfoStatusDetail = "DISABLED"

	ThingStatusInfoStatusDetailDUTYCYCLE ThingStatusInfoStatusDetail = "DUTY_CYCLE"

	ThingStatusInfoStatusDetailFIRMWAREUPDATING ThingStatusInfoStatusDetail = "FIRMWARE_UPDATING"

	ThingStatusInfoStatusDetailGONE ThingStatusInfoStatusDetail = "GONE"

	ThingStatusInfoStatusDetailHANDLERCONFIGURATIONPENDING ThingStatusInfoStatusDetail = "HANDLER_CONFIGURATION_PENDING"

	ThingStatusInfoStatusDetailHANDLERINITIALIZINGERROR ThingStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"

	ThingStatusInfoStatusDetailHANDLERMISSINGERROR ThingStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"

	ThingStatusInfoStatusDetailHANDLERREGISTERINGERROR ThingStatusInfoStatusDetail = "HANDLER_REGISTERING_ERROR"

	ThingStatusInfoStatusDetailNONE ThingStatusInfoStatusDetail = "NONE"
)

// Action defines model for Action.
type Action struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Inputs        *Action_Inputs `json:"inputs,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// Action_Inputs defines model for Action.Inputs.
type Action_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ActionDTO defines model for ActionDTO.
type ActionDTO struct {
	Configuration *ActionDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                  `json:"description,omitempty"`
	Id            *string                  `json:"id,omitempty"`
	Inputs        *ActionDTO_Inputs        `json:"inputs,omitempty"`
	Label         *string                  `json:"label,omitempty"`
	Type          *string                  `json:"type,omitempty"`
}

// ActionDTO_Configuration defines model for ActionDTO.Configuration.
type ActionDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ActionDTO_Inputs defines model for ActionDTO.Inputs.
type ActionDTO_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Addon defines model for Addon.
type Addon struct {
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	Description     *string `json:"description,omitempty"`
	Id              *string `json:"id,omitempty"`
	ImageLink       *string `json:"imageLink,omitempty"`
	Installed       *bool   `json:"installed,omitempty"`
	Label           *string `json:"label,omitempty"`
	Link            *string `json:"link,omitempty"`
	Type            *string `json:"type,omitempty"`
	Version         *string `json:"version,omitempty"`
}

// AddonType defines model for AddonType.
type AddonType struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSinkDTO defines model for AudioSinkDTO.
type AudioSinkDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSourceDTO defines model for AudioSourceDTO.
type AudioSourceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// BindingInfoDTO defines model for BindingInfoDTO.
type BindingInfoDTO struct {
	Author               *string `json:"author,omitempty"`
	ConfigDescriptionURI *string `json:"configDescriptionURI,omitempty"`
	Description          *string `json:"description,omitempty"`
	Id                   *string `json:"id,omitempty"`
	Name                 *string `json:"name,omitempty"`
}

// ChannelDTO defines model for ChannelDTO.
type ChannelDTO struct {
	AutoUpdatePolicy *string                   `json:"autoUpdatePolicy,omitempty"`
	ChannelTypeUID   *string                   `json:"channelTypeUID,omitempty"`
	Configuration    *ChannelDTO_Configuration `json:"configuration,omitempty"`
	DefaultTags      *[]string                 `json:"defaultTags,omitempty"`
	Description      *string                   `json:"description,omitempty"`
	Id               *string                   `json:"id,omitempty"`
	ItemType         *string                   `json:"itemType,omitempty"`
	Kind             *string                   `json:"kind,omitempty"`
	Label            *string                   `json:"label,omitempty"`
	Properties       *ChannelDTO_Properties    `json:"properties,omitempty"`
	Uid              *string                   `json:"uid,omitempty"`
}

// ChannelDTO_Configuration defines model for ChannelDTO.Configuration.
type ChannelDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ChannelDTO_Properties defines model for ChannelDTO.Properties.
type ChannelDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ChannelDefinitionDTO defines model for ChannelDefinitionDTO.
type ChannelDefinitionDTO struct {
	Advanced         *bool                            `json:"advanced,omitempty"`
	Category         *string                          `json:"category,omitempty"`
	Description      *string                          `json:"description,omitempty"`
	Id               *string                          `json:"id,omitempty"`
	Label            *string                          `json:"label,omitempty"`
	Properties       *ChannelDefinitionDTO_Properties `json:"properties,omitempty"`
	StateDescription *StateDescription                `json:"stateDescription,omitempty"`
	Tags             *[]string                        `json:"tags,omitempty"`
	TypeUID          *string                          `json:"typeUID,omitempty"`
}

// ChannelDefinitionDTO_Properties defines model for ChannelDefinitionDTO.Properties.
type ChannelDefinitionDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ChannelGroupDefinitionDTO defines model for ChannelGroupDefinitionDTO.
type ChannelGroupDefinitionDTO struct {
	Channels    *[]ChannelDefinitionDTO `json:"channels,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Label       *string                 `json:"label,omitempty"`
}

// ChannelTypeDTO defines model for ChannelTypeDTO.
type ChannelTypeDTO struct {
	UID                *string                               `json:"UID,omitempty"`
	Advanced           *bool                                 `json:"advanced,omitempty"`
	Category           *string                               `json:"category,omitempty"`
	CommandDescription *CommandDescription                   `json:"commandDescription,omitempty"`
	Description        *string                               `json:"description,omitempty"`
	ItemType           *string                               `json:"itemType,omitempty"`
	Kind               *string                               `json:"kind,omitempty"`
	Label              *string                               `json:"label,omitempty"`
	ParameterGroups    *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters         *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	StateDescription   *StateDescription                     `json:"stateDescription,omitempty"`
	Tags               *[]string                             `json:"tags,omitempty"`
}

// CommandDescription defines model for CommandDescription.
type CommandDescription struct {
	CommandOptions *[]CommandOption `json:"commandOptions,omitempty"`
}

// CommandOption defines model for CommandOption.
type CommandOption struct {
	Command *string `json:"command,omitempty"`
	Label   *string `json:"label,omitempty"`
}

// Condition defines model for Condition.
type Condition struct {
	Configuration *Configuration    `json:"configuration,omitempty"`
	Description   *string           `json:"description,omitempty"`
	Id            *string           `json:"id,omitempty"`
	Inputs        *Condition_Inputs `json:"inputs,omitempty"`
	Label         *string           `json:"label,omitempty"`
	TypeUID       *string           `json:"typeUID,omitempty"`
}

// Condition_Inputs defines model for Condition.Inputs.
type Condition_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ConditionDTO defines model for ConditionDTO.
type ConditionDTO struct {
	Configuration *ConditionDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                     `json:"description,omitempty"`
	Id            *string                     `json:"id,omitempty"`
	Inputs        *ConditionDTO_Inputs        `json:"inputs,omitempty"`
	Label         *string                     `json:"label,omitempty"`
	Type          *string                     `json:"type,omitempty"`
}

// ConditionDTO_Configuration defines model for ConditionDTO.Configuration.
type ConditionDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ConditionDTO_Inputs defines model for ConditionDTO.Inputs.
type ConditionDTO_Inputs struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ConfigDescriptionDTO defines model for ConfigDescriptionDTO.
type ConfigDescriptionDTO struct {
	ParameterGroups *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters      *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	Uri             *string                               `json:"uri,omitempty"`
}

// ConfigDescriptionParameter defines model for ConfigDescriptionParameter.
type ConfigDescriptionParameter struct {
	Advanced       *bool                           `json:"advanced,omitempty"`
	Context        *string                         `json:"context,omitempty"`
	Default        *string                         `json:"default,omitempty"`
	Description    *string                         `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteria               `json:"filterCriteria,omitempty"`
	GroupName      *string                         `json:"groupName,omitempty"`
	Label          *string                         `json:"label,omitempty"`
	LimitToOptions *bool                           `json:"limitToOptions,omitempty"`
	Maximum        *float32                        `json:"maximum,omitempty"`
	Minimum        *float32                        `json:"minimum,omitempty"`
	Multiple       *bool                           `json:"multiple,omitempty"`
	MultipleLimit  *int32                          `json:"multipleLimit,omitempty"`
	Name           *string                         `json:"name,omitempty"`
	Options        *[]ParameterOption              `json:"options,omitempty"`
	Pattern        *string                         `json:"pattern,omitempty"`
	ReadOnly       *bool                           `json:"readOnly,omitempty"`
	Required       *bool                           `json:"required,omitempty"`
	StepSize       *float32                        `json:"stepSize,omitempty"`
	Type           *ConfigDescriptionParameterType `json:"type,omitempty"`
	Unit           *string                         `json:"unit,omitempty"`
	UnitLabel      *string                         `json:"unitLabel,omitempty"`
	Verifyable     *bool                           `json:"verifyable,omitempty"`
}

// ConfigDescriptionParameterType defines model for ConfigDescriptionParameter.Type.
type ConfigDescriptionParameterType string

// ConfigDescriptionParameterDTO defines model for ConfigDescriptionParameterDTO.
type ConfigDescriptionParameterDTO struct {
	Advanced       *bool                              `json:"advanced,omitempty"`
	Context        *string                            `json:"context,omitempty"`
	DefaultValue   *string                            `json:"defaultValue,omitempty"`
	Description    *string                            `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteriaDTO               `json:"filterCriteria,omitempty"`
	GroupName      *string                            `json:"groupName,omitempty"`
	Label          *string                            `json:"label,omitempty"`
	LimitToOptions *bool                              `json:"limitToOptions,omitempty"`
	Max            *float32                           `json:"max,omitempty"`
	Min            *float32                           `json:"min,omitempty"`
	Multiple       *bool                              `json:"multiple,omitempty"`
	MultipleLimit  *int32                             `json:"multipleLimit,omitempty"`
	Name           *string                            `json:"name,omitempty"`
	Options        *[]ParameterOptionDTO              `json:"options,omitempty"`
	Pattern        *string                            `json:"pattern,omitempty"`
	ReadOnly       *bool                              `json:"readOnly,omitempty"`
	Required       *bool                              `json:"required,omitempty"`
	Stepsize       *float32                           `json:"stepsize,omitempty"`
	Type           *ConfigDescriptionParameterDTOType `json:"type,omitempty"`
	Unit           *string                            `json:"unit,omitempty"`
	UnitLabel      *string                            `json:"unitLabel,omitempty"`
	Verify         *bool                              `json:"verify,omitempty"`
}

// ConfigDescriptionParameterDTOType defines model for ConfigDescriptionParameterDTO.Type.
type ConfigDescriptionParameterDTOType string

// ConfigDescriptionParameterGroupDTO defines model for ConfigDescriptionParameterGroupDTO.
type ConfigDescriptionParameterGroupDTO struct {
	Advanced    *bool   `json:"advanced,omitempty"`
	Context     *string `json:"context,omitempty"`
	Description *string `json:"description,omitempty"`
	Label       *string `json:"label,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ConfigStatusMessage defines model for ConfigStatusMessage.
type ConfigStatusMessage struct {
	Message       *string                  `json:"message,omitempty"`
	ParameterName *string                  `json:"parameterName,omitempty"`
	StatusCode    *int32                   `json:"statusCode,omitempty"`
	Type          *ConfigStatusMessageType `json:"type,omitempty"`
}

// ConfigStatusMessageType defines model for ConfigStatusMessage.Type.
type ConfigStatusMessageType string

// ConfigurableServiceDTO defines model for ConfigurableServiceDTO.
type ConfigurableServiceDTO struct {
	Category             *string `json:"category,omitempty"`
	ConfigDescriptionURI *string `json:"configDescriptionURI,omitempty"`
	Id                   *string `json:"id,omitempty"`
	Label                *string `json:"label,omitempty"`
	Multiple             *bool   `json:"multiple,omitempty"`
}

// Configuration defines model for Configuration.
type Configuration struct {
	Properties *Configuration_Properties `json:"properties,omitempty"`
}

// Configuration_Properties defines model for Configuration.Properties.
type Configuration_Properties struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// DiscoveryResultDTO defines model for DiscoveryResultDTO.
type DiscoveryResultDTO struct {
	BridgeUID              *string                        `json:"bridgeUID,omitempty"`
	Flag                   *DiscoveryResultDTOFlag        `json:"flag,omitempty"`
	Label                  *string                        `json:"label,omitempty"`
	Properties             *DiscoveryResultDTO_Properties `json:"properties,omitempty"`
	RepresentationProperty *string                        `json:"representationProperty,omitempty"`
	ThingTypeUID           *string                        `json:"thingTypeUID,omitempty"`
	ThingUID               *string                        `json:"thingUID,omitempty"`
}

// DiscoveryResultDTOFlag defines model for DiscoveryResultDTO.Flag.
type DiscoveryResultDTOFlag string

// DiscoveryResultDTO_Properties defines model for DiscoveryResultDTO.Properties.
type DiscoveryResultDTO_Properties struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedItemChannelLinkDTO defines model for EnrichedItemChannelLinkDTO.
type EnrichedItemChannelLinkDTO struct {
	ChannelUID    *string                                   `json:"channelUID,omitempty"`
	Configuration *EnrichedItemChannelLinkDTO_Configuration `json:"configuration,omitempty"`
	Editable      *bool                                     `json:"editable,omitempty"`
	ItemName      *string                                   `json:"itemName,omitempty"`
}

// EnrichedItemChannelLinkDTO_Configuration defines model for EnrichedItemChannelLinkDTO.Configuration.
type EnrichedItemChannelLinkDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedItemDTO defines model for EnrichedItemDTO.
type EnrichedItemDTO struct {
	Category           *string                   `json:"category,omitempty"`
	CommandDescription *CommandDescription       `json:"commandDescription,omitempty"`
	Editable           *bool                     `json:"editable,omitempty"`
	GroupNames         *[]string                 `json:"groupNames,omitempty"`
	Label              *string                   `json:"label,omitempty"`
	Link               *string                   `json:"link,omitempty"`
	Metadata           *EnrichedItemDTO_Metadata `json:"metadata,omitempty"`
	Name               *string                   `json:"name,omitempty"`
	State              *string                   `json:"state,omitempty"`
	StateDescription   *StateDescription         `json:"stateDescription,omitempty"`
	Tags               *[]string                 `json:"tags,omitempty"`
	TransformedState   *string                   `json:"transformedState,omitempty"`
	Type               *string                   `json:"type,omitempty"`
}

// EnrichedItemDTO_Metadata defines model for EnrichedItemDTO.Metadata.
type EnrichedItemDTO_Metadata struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedRuleDTO defines model for EnrichedRuleDTO.
type EnrichedRuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Configuration      *EnrichedRuleDTO_Configuration   `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Editable           *bool                            `json:"editable,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Status             *RuleStatusInfo                  `json:"status,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *EnrichedRuleDTOVisibility       `json:"visibility,omitempty"`
}

// EnrichedRuleDTO_Configuration defines model for EnrichedRuleDTO.Configuration.
type EnrichedRuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedRuleDTOVisibility defines model for EnrichedRuleDTO.Visibility.
type EnrichedRuleDTOVisibility string

// EnrichedThingDTO defines model for EnrichedThingDTO.
type EnrichedThingDTO struct {
	UID            *string                         `json:"UID,omitempty"`
	BridgeUID      *string                         `json:"bridgeUID,omitempty"`
	Channels       *[]ChannelDTO                   `json:"channels,omitempty"`
	Configuration  *EnrichedThingDTO_Configuration `json:"configuration,omitempty"`
	Editable       *bool                           `json:"editable,omitempty"`
	FirmwareStatus *FirmwareStatusDTO              `json:"firmwareStatus,omitempty"`
	Label          *string                         `json:"label,omitempty"`
	Location       *string                         `json:"location,omitempty"`
	Properties     *EnrichedThingDTO_Properties    `json:"properties,omitempty"`
	StatusInfo     *ThingStatusInfo                `json:"statusInfo,omitempty"`
	ThingTypeUID   *string                         `json:"thingTypeUID,omitempty"`
}

// EnrichedThingDTO_Configuration defines model for EnrichedThingDTO.Configuration.
type EnrichedThingDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// EnrichedThingDTO_Properties defines model for EnrichedThingDTO.Properties.
type EnrichedThingDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// FilterCriteria defines model for FilterCriteria.
type FilterCriteria struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FilterCriteriaDTO defines model for FilterCriteriaDTO.
type FilterCriteriaDTO struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FirmwareDTO defines model for FirmwareDTO.
type FirmwareDTO struct {
	Changelog           *string `json:"changelog,omitempty"`
	Description         *string `json:"description,omitempty"`
	Model               *string `json:"model,omitempty"`
	ModelRestricted     *bool   `json:"modelRestricted,omitempty"`
	PrerequisiteVersion *string `json:"prerequisiteVersion,omitempty"`
	ThingTypeUID        *string `json:"thingTypeUID,omitempty"`
	Vendor              *string `json:"vendor,omitempty"`
	Version             *string `json:"version,omitempty"`
}

// FirmwareStatusDTO defines model for FirmwareStatusDTO.
type FirmwareStatusDTO struct {
	Status           *string `json:"status,omitempty"`
	UpdatableVersion *string `json:"updatableVersion,omitempty"`
}

// GroupFunctionDTO defines model for GroupFunctionDTO.
type GroupFunctionDTO struct {
	Name   *string   `json:"name,omitempty"`
	Params *[]string `json:"params,omitempty"`
}

// GroupItemDTO defines model for GroupItemDTO.
type GroupItemDTO struct {
	Category   *string           `json:"category,omitempty"`
	Function   *GroupFunctionDTO `json:"function,omitempty"`
	GroupNames *[]string         `json:"groupNames,omitempty"`
	GroupType  *string           `json:"groupType,omitempty"`
	Label      *string           `json:"label,omitempty"`
	Name       *string           `json:"name,omitempty"`
	Tags       *[]string         `json:"tags,omitempty"`
	Type       *string           `json:"type,omitempty"`
}

// HistoryDataBean defines model for HistoryDataBean.
type HistoryDataBean struct {
	State *string `json:"state,omitempty"`
	Time  *int64  `json:"time,omitempty"`
}

// HumanLanguageInterpreterDTO defines model for HumanLanguageInterpreterDTO.
type HumanLanguageInterpreterDTO struct {
	Id      *string   `json:"id,omitempty"`
	Label   *string   `json:"label,omitempty"`
	Locales *[]string `json:"locales,omitempty"`
}

// IconSet defines model for IconSet.
type IconSet struct {
	Description *string           `json:"description,omitempty"`
	Formats     *[]IconSetFormats `json:"formats,omitempty"`
	Id          *string           `json:"id,omitempty"`
	Label       *string           `json:"label,omitempty"`
}

// IconSetFormats defines model for IconSet.Formats.
type IconSetFormats string

// ItemChannelLinkDTO defines model for ItemChannelLinkDTO.
type ItemChannelLinkDTO struct {
	ChannelUID    *string                           `json:"channelUID,omitempty"`
	Configuration *ItemChannelLinkDTO_Configuration `json:"configuration,omitempty"`
	ItemName      *string                           `json:"itemName,omitempty"`
}

// ItemChannelLinkDTO_Configuration defines model for ItemChannelLinkDTO.Configuration.
type ItemChannelLinkDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ItemHistoryDTO defines model for ItemHistoryDTO.
type ItemHistoryDTO struct {
	Data         *[]HistoryDataBean `json:"data,omitempty"`
	Datapoints   *string            `json:"datapoints,omitempty"`
	Name         *string            `json:"name,omitempty"`
	Totalrecords *string            `json:"totalrecords,omitempty"`
}

// Links defines model for Links.
type Links struct {
	Type *string `json:"type,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// MappingDTO defines model for MappingDTO.
type MappingDTO struct {
	Command *string `json:"command,omitempty"`
	Label   *string `json:"label,omitempty"`
}

// MetadataDTO defines model for MetadataDTO.
type MetadataDTO struct {
	Config *MetadataDTO_Config `json:"config,omitempty"`
	Value  *string             `json:"value,omitempty"`
}

// MetadataDTO_Config defines model for MetadataDTO.Config.
type MetadataDTO_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Module defines model for Module.
type Module struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// ModuleDTO defines model for ModuleDTO.
type ModuleDTO struct {
	Configuration *ModuleDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                  `json:"description,omitempty"`
	Id            *string                  `json:"id,omitempty"`
	Label         *string                  `json:"label,omitempty"`
	Type          *string                  `json:"type,omitempty"`
}

// ModuleDTO_Configuration defines model for ModuleDTO.Configuration.
type ModuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ModuleTypeDTO defines model for ModuleTypeDTO.
type ModuleTypeDTO struct {
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Label              *string                          `json:"label,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *ModuleTypeDTOVisibility         `json:"visibility,omitempty"`
}

// ModuleTypeDTOVisibility defines model for ModuleTypeDTO.Visibility.
type ModuleTypeDTOVisibility string

// PageDTO defines model for PageDTO.
type PageDTO struct {
	Icon    *string      `json:"icon,omitempty"`
	Id      *string      `json:"id,omitempty"`
	Leaf    *bool        `json:"leaf,omitempty"`
	Link    *string      `json:"link,omitempty"`
	Parent  *PageDTO     `json:"parent,omitempty"`
	Timeout *bool        `json:"timeout,omitempty"`
	Title   *string      `json:"title,omitempty"`
	Widgets *[]WidgetDTO `json:"widgets,omitempty"`
}

// ParameterOption defines model for ParameterOption.
type ParameterOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ParameterOptionDTO defines model for ParameterOptionDTO.
type ParameterOptionDTO struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// PersistenceItemInfo defines model for PersistenceItemInfo.
type PersistenceItemInfo struct {
	Count    *int32     `json:"count,omitempty"`
	Earliest *time.Time `json:"earliest,omitempty"`
	Latest   *time.Time `json:"latest,omitempty"`
	Name     *string    `json:"name,omitempty"`
}

// PersistenceServiceDTO defines model for PersistenceServiceDTO.
type PersistenceServiceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// ProfileTypeDTO defines model for ProfileTypeDTO.
type ProfileTypeDTO struct {
	Kind               *string   `json:"kind,omitempty"`
	Label              *string   `json:"label,omitempty"`
	SupportedItemTypes *[]string `json:"supportedItemTypes,omitempty"`
	Uid                *string   `json:"uid,omitempty"`
}

// RootBean defines model for RootBean.
type RootBean struct {
	Links             *[]Links     `json:"links,omitempty"`
	Locale            *string      `json:"locale,omitempty"`
	MeasurementSystem *string      `json:"measurementSystem,omitempty"`
	RuntimeInfo       *RuntimeInfo `json:"runtimeInfo,omitempty"`
	Version           *string      `json:"version,omitempty"`
}

// RootUIComponent defines model for RootUIComponent.
type RootUIComponent struct {
	Config    *RootUIComponent_Config `json:"config,omitempty"`
	Props     *ConfigDescriptionDTO   `json:"props,omitempty"`
	Slots     *RootUIComponent_Slots  `json:"slots,omitempty"`
	Tags      *[]string               `json:"tags,omitempty"`
	Timestamp *time.Time              `json:"timestamp,omitempty"`
	Type      *string                 `json:"type,omitempty"`
	Uid       *string                 `json:"uid,omitempty"`
}

// RootUIComponent_Config defines model for RootUIComponent.Config.
type RootUIComponent_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// RootUIComponent_Slots defines model for RootUIComponent.Slots.
type RootUIComponent_Slots struct {
	AdditionalProperties map[string][]UIComponent `json:"-"`
}

// Rule defines model for Rule.
type Rule struct {
	Actions                   *[]Action                     `json:"actions,omitempty"`
	Conditions                *[]Condition                  `json:"conditions,omitempty"`
	Configuration             *Configuration                `json:"configuration,omitempty"`
	ConfigurationDescriptions *[]ConfigDescriptionParameter `json:"configurationDescriptions,omitempty"`
	Description               *string                       `json:"description,omitempty"`
	Modules                   *[]Module                     `json:"modules,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	Tags                      *[]string                     `json:"tags,omitempty"`
	TemplateUID               *string                       `json:"templateUID,omitempty"`
	Triggers                  *[]Trigger                    `json:"triggers,omitempty"`
	Uid                       *string                       `json:"uid,omitempty"`
	Visibility                *RuleVisibility               `json:"visibility,omitempty"`
}

// RuleVisibility defines model for Rule.Visibility.
type RuleVisibility string

// RuleDTO defines model for RuleDTO.
type RuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Configuration      *RuleDTO_Configuration           `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *RuleDTOVisibility               `json:"visibility,omitempty"`
}

// RuleDTO_Configuration defines model for RuleDTO.Configuration.
type RuleDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// RuleDTOVisibility defines model for RuleDTO.Visibility.
type RuleDTOVisibility string

// RuleExecution defines model for RuleExecution.
type RuleExecution struct {
	Date *time.Time `json:"date,omitempty"`
	Rule *Rule      `json:"rule,omitempty"`
}

// RuleStatusInfo defines model for RuleStatusInfo.
type RuleStatusInfo struct {
	Description  *string                     `json:"description,omitempty"`
	Status       *RuleStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *RuleStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// RuleStatusInfoStatus defines model for RuleStatusInfo.Status.
type RuleStatusInfoStatus string

// RuleStatusInfoStatusDetail defines model for RuleStatusInfo.StatusDetail.
type RuleStatusInfoStatusDetail string

// RuntimeInfo defines model for RuntimeInfo.
type RuntimeInfo struct {
	BuildString *string `json:"buildString,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// SitemapDTO defines model for SitemapDTO.
type SitemapDTO struct {
	Homepage *PageDTO `json:"homepage,omitempty"`
	Icon     *string  `json:"icon,omitempty"`
	Label    *string  `json:"label,omitempty"`
	Link     *string  `json:"link,omitempty"`
	Name     *string  `json:"name,omitempty"`
}

// StateDescription defines model for StateDescription.
type StateDescription struct {
	Maximum  *float32       `json:"maximum,omitempty"`
	Minimum  *float32       `json:"minimum,omitempty"`
	Options  *[]StateOption `json:"options,omitempty"`
	Pattern  *string        `json:"pattern,omitempty"`
	ReadOnly *bool          `json:"readOnly,omitempty"`
	Step     *float32       `json:"step,omitempty"`
}

// StateOption defines model for StateOption.
type StateOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// StrippedThingTypeDTO defines model for StrippedThingTypeDTO.
type StrippedThingTypeDTO struct {
	UID                     *string   `json:"UID,omitempty"`
	Bridge                  *bool     `json:"bridge,omitempty"`
	Category                *string   `json:"category,omitempty"`
	Description             *string   `json:"description,omitempty"`
	Label                   *string   `json:"label,omitempty"`
	Listed                  *bool     `json:"listed,omitempty"`
	SupportedBridgeTypeUIDs *[]string `json:"supportedBridgeTypeUIDs,omitempty"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	AvailableProcessors *int32  `json:"availableProcessors,omitempty"`
	ConfigFolder        *string `json:"configFolder,omitempty"`
	FreeMemory          *int64  `json:"freeMemory,omitempty"`
	JavaVendor          *string `json:"javaVendor,omitempty"`
	JavaVendorVersion   *string `json:"javaVendorVersion,omitempty"`
	JavaVersion         *string `json:"javaVersion,omitempty"`
	LogFolder           *string `json:"logFolder,omitempty"`
	OsArchitecture      *string `json:"osArchitecture,omitempty"`
	OsName              *string `json:"osName,omitempty"`
	OsVersion           *string `json:"osVersion,omitempty"`
	TotalMemory         *int64  `json:"totalMemory,omitempty"`
	UserdataFolder      *string `json:"userdataFolder,omitempty"`
}

// SystemInfoBean defines model for SystemInfoBean.
type SystemInfoBean struct {
	SystemInfo *SystemInfo `json:"systemInfo,omitempty"`
}

// Template defines model for Template.
type Template struct {
	Description *string             `json:"description,omitempty"`
	Label       *string             `json:"label,omitempty"`
	Tags        *[]string           `json:"tags,omitempty"`
	Uid         *string             `json:"uid,omitempty"`
	Visibility  *TemplateVisibility `json:"visibility,omitempty"`
}

// TemplateVisibility defines model for Template.Visibility.
type TemplateVisibility string

// ThingDTO defines model for ThingDTO.
type ThingDTO struct {
	UID           *string                 `json:"UID,omitempty"`
	BridgeUID     *string                 `json:"bridgeUID,omitempty"`
	Channels      *[]ChannelDTO           `json:"channels,omitempty"`
	Configuration *ThingDTO_Configuration `json:"configuration,omitempty"`
	Label         *string                 `json:"label,omitempty"`
	Location      *string                 `json:"location,omitempty"`
	Properties    *ThingDTO_Properties    `json:"properties,omitempty"`
	ThingTypeUID  *string                 `json:"thingTypeUID,omitempty"`
}

// ThingDTO_Configuration defines model for ThingDTO.Configuration.
type ThingDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// ThingDTO_Properties defines model for ThingDTO.Properties.
type ThingDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// ThingStatusInfo defines model for ThingStatusInfo.
type ThingStatusInfo struct {
	Description  *string                      `json:"description,omitempty"`
	Status       *ThingStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *ThingStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// ThingStatusInfoStatus defines model for ThingStatusInfo.Status.
type ThingStatusInfoStatus string

// ThingStatusInfoStatusDetail defines model for ThingStatusInfo.StatusDetail.
type ThingStatusInfoStatusDetail string

// ThingTypeDTO defines model for ThingTypeDTO.
type ThingTypeDTO struct {
	UID                      *string                               `json:"UID,omitempty"`
	Bridge                   *bool                                 `json:"bridge,omitempty"`
	Category                 *string                               `json:"category,omitempty"`
	ChannelGroups            *[]ChannelGroupDefinitionDTO          `json:"channelGroups,omitempty"`
	Channels                 *[]ChannelDefinitionDTO               `json:"channels,omitempty"`
	ConfigParameters         *[]ConfigDescriptionParameterDTO      `json:"configParameters,omitempty"`
	Description              *string                               `json:"description,omitempty"`
	ExtensibleChannelTypeIds *[]string                             `json:"extensibleChannelTypeIds,omitempty"`
	Label                    *string                               `json:"label,omitempty"`
	Listed                   *bool                                 `json:"listed,omitempty"`
	ParameterGroups          *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Properties               *ThingTypeDTO_Properties              `json:"properties,omitempty"`
	SupportedBridgeTypeUIDs  *[]string                             `json:"supportedBridgeTypeUIDs,omitempty"`
}

// ThingTypeDTO_Properties defines model for ThingTypeDTO.Properties.
type ThingTypeDTO_Properties struct {
	AdditionalProperties map[string]string `json:"-"`
}

// TileDTO defines model for TileDTO.
type TileDTO struct {
	ImageUrl *string `json:"imageUrl,omitempty"`
	Name     *string `json:"name,omitempty"`
	Overlay  *string `json:"overlay,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// TokenResponseDTO defines model for TokenResponseDTO.
type TokenResponseDTO struct {
	AccessToken  *string  `json:"access_token,omitempty"`
	ExpiresIn    *int32   `json:"expires_in,omitempty"`
	RefreshToken *string  `json:"refresh_token,omitempty"`
	Scope        *string  `json:"scope,omitempty"`
	TokenType    *string  `json:"token_type,omitempty"`
	User         *UserDTO `json:"user,omitempty"`
}

// Trigger defines model for Trigger.
type Trigger struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// TriggerDTO defines model for TriggerDTO.
type TriggerDTO struct {
	Configuration *TriggerDTO_Configuration `json:"configuration,omitempty"`
	Description   *string                   `json:"description,omitempty"`
	Id            *string                   `json:"id,omitempty"`
	Label         *string                   `json:"label,omitempty"`
	Type          *string                   `json:"type,omitempty"`
}

// TriggerDTO_Configuration defines model for TriggerDTO.Configuration.
type TriggerDTO_Configuration struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UIComponent defines model for UIComponent.
type UIComponent struct {
	Config *UIComponent_Config `json:"config,omitempty"`
	Type   *string             `json:"type,omitempty"`
}

// UIComponent_Config defines model for UIComponent.Config.
type UIComponent_Config struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UserApiTokenDTO defines model for UserApiTokenDTO.
type UserApiTokenDTO struct {
	CreatedTime *time.Time `json:"createdTime,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Scope       *string    `json:"scope,omitempty"`
}

// UserDTO defines model for UserDTO.
type UserDTO struct {
	Name  *string   `json:"name,omitempty"`
	Roles *[]string `json:"roles,omitempty"`
}

// UserSessionDTO defines model for UserSessionDTO.
type UserSessionDTO struct {
	ClientId        *string    `json:"clientId,omitempty"`
	CreatedTime     *time.Time `json:"createdTime,omitempty"`
	LastRefreshTime *time.Time `json:"lastRefreshTime,omitempty"`
	Scope           *string    `json:"scope,omitempty"`
	SessionId       *string    `json:"sessionId,omitempty"`
}

// VoiceDTO defines model for VoiceDTO.
type VoiceDTO struct {
	Id     *string `json:"id,omitempty"`
	Label  *string `json:"label,omitempty"`
	Locale *string `json:"locale,omitempty"`
}

// WidgetDTO defines model for WidgetDTO.
type WidgetDTO struct {
	Encoding      *string          `json:"encoding,omitempty"`
	Height        *int32           `json:"height,omitempty"`
	Icon          *string          `json:"icon,omitempty"`
	Item          *EnrichedItemDTO `json:"item,omitempty"`
	Label         *string          `json:"label,omitempty"`
	Labelcolor    *string          `json:"labelcolor,omitempty"`
	Legend        *bool            `json:"legend,omitempty"`
	LinkedPage    *PageDTO         `json:"linkedPage,omitempty"`
	Mappings      *[]MappingDTO    `json:"mappings,omitempty"`
	MaxValue      *float32         `json:"maxValue,omitempty"`
	MinValue      *float32         `json:"minValue,omitempty"`
	Name          *string          `json:"name,omitempty"`
	Period        *string          `json:"period,omitempty"`
	Refresh       *int32           `json:"refresh,omitempty"`
	SendFrequency *int32           `json:"sendFrequency,omitempty"`
	Separator     *string          `json:"separator,omitempty"`
	Service       *string          `json:"service,omitempty"`
	State         *string          `json:"state,omitempty"`
	Step          *float32         `json:"step,omitempty"`
	SwitchSupport *bool            `json:"switchSupport,omitempty"`
	Type          *string          `json:"type,omitempty"`
	Url           *string          `json:"url,omitempty"`
	Valuecolor    *string          `json:"valuecolor,omitempty"`
	Visibility    *bool            `json:"visibility,omitempty"`
	WidgetId      *string          `json:"widgetId,omitempty"`
}

// GetAddonsParams defines parameters for GetAddons.
type GetAddonsParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonTypesParams defines parameters for GetAddonTypes.
type GetAddonTypesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonByIdParams defines parameters for GetAddonById.
type GetAddonByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioDefaultSinkParams defines parameters for GetAudioDefaultSink.
type GetAudioDefaultSinkParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioDefaultSourceParams defines parameters for GetAudioDefaultSource.
type GetAudioDefaultSourceParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSinksParams defines parameters for GetAudioSinks.
type GetAudioSinksParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSourcesParams defines parameters for GetAudioSources.
type GetAudioSourcesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetOAuthTokenParams defines parameters for GetOAuthToken.
type GetOAuthTokenParams struct {
	UseCookie *bool `json:"useCookie,omitempty"`
}

// GetBindingsParams defines parameters for GetBindings.
type GetBindingsParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateBindingConfigurationJSONBody defines parameters for UpdateBindingConfiguration.
type UpdateBindingConfigurationJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// GetChannelTypesParams defines parameters for GetChannelTypes.
type GetChannelTypesParams struct {
	// filter UIDs by prefix (multiple comma-separated prefixes allowed, for example: 'system,mqtt')
	Prefixes *string `json:"prefixes,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetChannelTypeByUIDParams defines parameters for GetChannelTypeByUID.
type GetChannelTypeByUIDParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionsParams defines parameters for GetConfigDescriptions.
type GetConfigDescriptionsParams struct {
	// scheme filter
	Scheme *string `json:"scheme,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionByURIParams defines parameters for GetConfigDescriptionByURI.
type GetConfigDescriptionByURIParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// topics
	Topics *string `json:"topics,omitempty"`
}

// GetIconSetsParams defines parameters for GetIconSets.
type GetIconSetsParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// ApproveInboxItemByIdParams defines parameters for ApproveInboxItemById.
type ApproveInboxItemByIdParams struct {
	// new thing ID
	NewThingId *string `json:"newThingId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsParams defines parameters for GetItems.
type GetItemsParams struct {
	// item type filter
	Type *string `json:"type,omitempty"`

	// item tag filter
	Tags *string `json:"tags,omitempty"`

	// metadata selector
	Metadata *string `json:"metadata,omitempty"`

	// get member items recursively
	Recursive *bool `json:"recursive,omitempty"`

	// limit output to the given fields (comma separated)
	Fields *string `json:"fields,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddOrUpdateItemsInRegistryJSONBody defines parameters for AddOrUpdateItemsInRegistry.
type AddOrUpdateItemsInRegistryJSONBody []GroupItemDTO

// GetItemByNameParams defines parameters for GetItemByName.
type GetItemByNameParams struct {
	// metadata selector
	Metadata *string `json:"metadata,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddOrUpdateItemInRegistryJSONBody defines parameters for AddOrUpdateItemInRegistry.
type AddOrUpdateItemInRegistryJSONBody GroupItemDTO

// AddOrUpdateItemInRegistryParams defines parameters for AddOrUpdateItemInRegistry.
type AddOrUpdateItemInRegistryParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddMetadataToItemJSONBody defines parameters for AddMetadataToItem.
type AddMetadataToItemJSONBody MetadataDTO

// UpdateItemStateParams defines parameters for UpdateItemState.
type UpdateItemStateParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemLinksParams defines parameters for GetItemLinks.
type GetItemLinksParams struct {
	// filter by channel UID
	ChannelUID *string `json:"channelUID,omitempty"`

	// filter by item name
	ItemName *string `json:"itemName,omitempty"`
}

// GetModuleTypesParams defines parameters for GetModuleTypes.
type GetModuleTypesParams struct {
	// tags for filtering
	Tags *string `json:"tags,omitempty"`

	// filtering by action, condition or trigger
	Type *string `json:"type,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetModuleTypeByIdParams defines parameters for GetModuleTypeById.
type GetModuleTypeByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetPersistenceServicesParams defines parameters for GetPersistenceServices.
type GetPersistenceServicesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsForPersistenceServiceParams defines parameters for GetItemsForPersistenceService.
type GetItemsForPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`
}

// DeleteItemFromPersistenceServiceParams defines parameters for DeleteItemFromPersistenceService.
type DeleteItemFromPersistenceServiceParams struct {
	// Id of the persistence service.
	ServiceId string `json:"serviceId"`

	// Start time of the data to return. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime string `json:"starttime"`

	// End time of the data to return. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime string `json:"endtime"`
}

// GetItemDataFromPersistenceServiceParams defines parameters for GetItemDataFromPersistenceService.
type GetItemDataFromPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`

	// Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime *string `json:"starttime,omitempty"`

	// End time of the data to return. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime *string `json:"endtime,omitempty"`

	// Page number of data to return. This parameter will enable paging.
	Page *int32 `json:"page,omitempty"`

	// The length of each page.
	Pagelength *int32 `json:"pagelength,omitempty"`

	// Gets one value before and after the requested period.
	Boundary *bool `json:"boundary,omitempty"`
}

// StoreItemDataInPersistenceServiceParams defines parameters for StoreItemDataInPersistenceService.
type StoreItemDataInPersistenceServiceParams struct {
	// Id of the persistence service. If not provided the default service will be used
	ServiceId *string `json:"serviceId,omitempty"`

	// Time of the data to be stored. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Time string `json:"time"`

	// The state to store.
	State string `json:"state"`
}

// GetProfileTypesParams defines parameters for GetProfileTypes.
type GetProfileTypesParams struct {
	// channel type filter
	ChannelTypeUID *string `json:"channelTypeUID,omitempty"`

	// item type filter
	ItemType *string `json:"itemType,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	Prefix *string   `json:"prefix,omitempty"`
	Tags   *[]string `json:"tags,omitempty"`

	// summary fields only
	Summary *bool `json:"summary,omitempty"`
}

// CreateRuleJSONBody defines parameters for CreateRule.
type CreateRuleJSONBody RuleDTO

// GetScheduleRuleSimulationsParams defines parameters for GetScheduleRuleSimulations.
type GetScheduleRuleSimulationsParams struct {
	// Start time of the simulated rule executions. Will default to the current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	From *string `json:"from,omitempty"`

	// End time of the simulated rule executions. Will default to 30 days after the start time. Must be less than 180 days after the given start time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Until *string `json:"until,omitempty"`
}

// UpdateRuleJSONBody defines parameters for UpdateRule.
type UpdateRuleJSONBody RuleDTO

// UpdateRuleConfigurationJSONBody defines parameters for UpdateRuleConfiguration.
type UpdateRuleConfigurationJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UpdateServiceConfigJSONBody defines parameters for UpdateServiceConfig.
type UpdateServiceConfigJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// GetSitemapEventsParams defines parameters for GetSitemapEvents.
type GetSitemapEventsParams struct {
	// sitemap name
	Sitemap *string `json:"sitemap,omitempty"`

	// page id
	Pageid *string `json:"pageid,omitempty"`
}

// GetSitemapByNameParams defines parameters for GetSitemapByName.
type GetSitemapByNameParams struct {
	Type         *string `json:"type,omitempty"`
	Jsoncallback *string `json:"jsoncallback,omitempty"`

	// include hidden widgets
	IncludeHidden *bool `json:"includeHidden,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// PollDataForSitemapParams defines parameters for PollDataForSitemap.
type PollDataForSitemapParams struct {
	// subscriptionid
	Subscriptionid *string `json:"subscriptionid,omitempty"`

	// include hidden widgets
	IncludeHidden *bool `json:"includeHidden,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplatesParams defines parameters for GetTemplates.
type GetTemplatesParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplateByIdParams defines parameters for GetTemplateById.
type GetTemplateByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypesParams defines parameters for GetThingTypes.
type GetThingTypesParams struct {
	// filter by binding Id
	BindingId *string `json:"bindingId,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypeByIdParams defines parameters for GetThingTypeById.
type GetThingTypeByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingsParams defines parameters for GetThings.
type GetThingsParams struct {
	// summary fields only
	Summary *bool `json:"summary,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CreateThingInRegistryJSONBody defines parameters for CreateThingInRegistry.
type CreateThingInRegistryJSONBody ThingDTO

// CreateThingInRegistryParams defines parameters for CreateThingInRegistry.
type CreateThingInRegistryParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// RemoveThingByIdParams defines parameters for RemoveThingById.
type RemoveThingByIdParams struct {
	// force
	Force *bool `json:"force,omitempty"`

	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingByIdParams defines parameters for GetThingById.
type GetThingByIdParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingJSONBody defines parameters for UpdateThing.
type UpdateThingJSONBody ThingDTO

// UpdateThingParams defines parameters for UpdateThing.
type UpdateThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingConfigJSONBody defines parameters for UpdateThingConfig.
type UpdateThingConfigJSONBody struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// UpdateThingConfigParams defines parameters for UpdateThingConfig.
type UpdateThingConfigParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingConfigStatusParams defines parameters for GetThingConfigStatus.
type GetThingConfigStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// EnableThingParams defines parameters for EnableThing.
type EnableThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingFirmwareStatusParams defines parameters for GetThingFirmwareStatus.
type GetThingFirmwareStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingFirmwareParams defines parameters for UpdateThingFirmware.
type UpdateThingFirmwareParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAvailableFirmwaresForThingParams defines parameters for GetAvailableFirmwaresForThing.
type GetAvailableFirmwaresForThingParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingStatusParams defines parameters for GetThingStatus.
type GetThingStatusParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRegisteredUIComponentsInNamespaceParams defines parameters for GetRegisteredUIComponentsInNamespace.
type GetRegisteredUIComponentsInNamespaceParams struct {
	// summary fields only
	Summary *bool `json:"summary,omitempty"`
}

// GetVoiceInterpretersParams defines parameters for GetVoiceInterpreters.
type GetVoiceInterpretersParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextByDefaultInterpreterParams defines parameters for InterpretTextByDefaultInterpreter.
type InterpretTextByDefaultInterpreterParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetVoiceInterpreterByUIDParams defines parameters for GetVoiceInterpreterByUID.
type GetVoiceInterpreterByUIDParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextParams defines parameters for InterpretText.
type InterpretTextParams struct {
	// language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// TextToSpeechParams defines parameters for TextToSpeech.
type TextToSpeechParams struct {
	// voice id
	Voiceid *string `json:"voiceid,omitempty"`

	// audio sink id
	Sinkid *string `json:"sinkid,omitempty"`
}

// UpdateBindingConfigurationJSONRequestBody defines body for UpdateBindingConfiguration for application/json ContentType.
type UpdateBindingConfigurationJSONRequestBody UpdateBindingConfigurationJSONBody

// AddOrUpdateItemsInRegistryJSONRequestBody defines body for AddOrUpdateItemsInRegistry for application/json ContentType.
type AddOrUpdateItemsInRegistryJSONRequestBody AddOrUpdateItemsInRegistryJSONBody

// AddOrUpdateItemInRegistryJSONRequestBody defines body for AddOrUpdateItemInRegistry for application/json ContentType.
type AddOrUpdateItemInRegistryJSONRequestBody AddOrUpdateItemInRegistryJSONBody

// AddMetadataToItemJSONRequestBody defines body for AddMetadataToItem for application/json ContentType.
type AddMetadataToItemJSONRequestBody AddMetadataToItemJSONBody

// CreateRuleJSONRequestBody defines body for CreateRule for application/json ContentType.
type CreateRuleJSONRequestBody CreateRuleJSONBody

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody UpdateRuleJSONBody

// UpdateRuleConfigurationJSONRequestBody defines body for UpdateRuleConfiguration for application/json ContentType.
type UpdateRuleConfigurationJSONRequestBody UpdateRuleConfigurationJSONBody

// UpdateServiceConfigJSONRequestBody defines body for UpdateServiceConfig for application/json ContentType.
type UpdateServiceConfigJSONRequestBody UpdateServiceConfigJSONBody

// CreateThingInRegistryJSONRequestBody defines body for CreateThingInRegistry for application/json ContentType.
type CreateThingInRegistryJSONRequestBody CreateThingInRegistryJSONBody

// UpdateThingJSONRequestBody defines body for UpdateThing for application/json ContentType.
type UpdateThingJSONRequestBody UpdateThingJSONBody

// UpdateThingConfigJSONRequestBody defines body for UpdateThingConfig for application/json ContentType.
type UpdateThingConfigJSONRequestBody UpdateThingConfigJSONBody

// Getter for additional properties for UpdateBindingConfigurationJSONBody. Returns the specified
// element and whether it was found
func (a UpdateBindingConfigurationJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateBindingConfigurationJSONBody
func (a *UpdateBindingConfigurationJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateBindingConfigurationJSONBody to handle AdditionalProperties
func (a *UpdateBindingConfigurationJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateBindingConfigurationJSONBody to handle AdditionalProperties
func (a UpdateBindingConfigurationJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateRuleConfigurationJSONBody. Returns the specified
// element and whether it was found
func (a UpdateRuleConfigurationJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateRuleConfigurationJSONBody
func (a *UpdateRuleConfigurationJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateRuleConfigurationJSONBody to handle AdditionalProperties
func (a *UpdateRuleConfigurationJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateRuleConfigurationJSONBody to handle AdditionalProperties
func (a UpdateRuleConfigurationJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateServiceConfigJSONBody. Returns the specified
// element and whether it was found
func (a UpdateServiceConfigJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateServiceConfigJSONBody
func (a *UpdateServiceConfigJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateServiceConfigJSONBody to handle AdditionalProperties
func (a *UpdateServiceConfigJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateServiceConfigJSONBody to handle AdditionalProperties
func (a UpdateServiceConfigJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateThingConfigJSONBody. Returns the specified
// element and whether it was found
func (a UpdateThingConfigJSONBody) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateThingConfigJSONBody
func (a *UpdateThingConfigJSONBody) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateThingConfigJSONBody to handle AdditionalProperties
func (a *UpdateThingConfigJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateThingConfigJSONBody to handle AdditionalProperties
func (a UpdateThingConfigJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Action_Inputs. Returns the specified
// element and whether it was found
func (a Action_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Action_Inputs
func (a *Action_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Action_Inputs to handle AdditionalProperties
func (a *Action_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Action_Inputs to handle AdditionalProperties
func (a Action_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActionDTO_Configuration. Returns the specified
// element and whether it was found
func (a ActionDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActionDTO_Configuration
func (a *ActionDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActionDTO_Configuration to handle AdditionalProperties
func (a *ActionDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActionDTO_Configuration to handle AdditionalProperties
func (a ActionDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActionDTO_Inputs. Returns the specified
// element and whether it was found
func (a ActionDTO_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActionDTO_Inputs
func (a *ActionDTO_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActionDTO_Inputs to handle AdditionalProperties
func (a *ActionDTO_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActionDTO_Inputs to handle AdditionalProperties
func (a ActionDTO_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDTO_Configuration. Returns the specified
// element and whether it was found
func (a ChannelDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDTO_Configuration
func (a *ChannelDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDTO_Configuration to handle AdditionalProperties
func (a *ChannelDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDTO_Configuration to handle AdditionalProperties
func (a ChannelDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDTO_Properties. Returns the specified
// element and whether it was found
func (a ChannelDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDTO_Properties
func (a *ChannelDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDTO_Properties to handle AdditionalProperties
func (a *ChannelDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDTO_Properties to handle AdditionalProperties
func (a ChannelDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChannelDefinitionDTO_Properties. Returns the specified
// element and whether it was found
func (a ChannelDefinitionDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChannelDefinitionDTO_Properties
func (a *ChannelDefinitionDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChannelDefinitionDTO_Properties to handle AdditionalProperties
func (a *ChannelDefinitionDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChannelDefinitionDTO_Properties to handle AdditionalProperties
func (a ChannelDefinitionDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Condition_Inputs. Returns the specified
// element and whether it was found
func (a Condition_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Condition_Inputs
func (a *Condition_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Condition_Inputs to handle AdditionalProperties
func (a *Condition_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Condition_Inputs to handle AdditionalProperties
func (a Condition_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConditionDTO_Configuration. Returns the specified
// element and whether it was found
func (a ConditionDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConditionDTO_Configuration
func (a *ConditionDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConditionDTO_Configuration to handle AdditionalProperties
func (a *ConditionDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConditionDTO_Configuration to handle AdditionalProperties
func (a ConditionDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConditionDTO_Inputs. Returns the specified
// element and whether it was found
func (a ConditionDTO_Inputs) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConditionDTO_Inputs
func (a *ConditionDTO_Inputs) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConditionDTO_Inputs to handle AdditionalProperties
func (a *ConditionDTO_Inputs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConditionDTO_Inputs to handle AdditionalProperties
func (a ConditionDTO_Inputs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Configuration_Properties. Returns the specified
// element and whether it was found
func (a Configuration_Properties) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Configuration_Properties
func (a *Configuration_Properties) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Configuration_Properties to handle AdditionalProperties
func (a *Configuration_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Configuration_Properties to handle AdditionalProperties
func (a Configuration_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DiscoveryResultDTO_Properties. Returns the specified
// element and whether it was found
func (a DiscoveryResultDTO_Properties) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DiscoveryResultDTO_Properties
func (a *DiscoveryResultDTO_Properties) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DiscoveryResultDTO_Properties to handle AdditionalProperties
func (a *DiscoveryResultDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DiscoveryResultDTO_Properties to handle AdditionalProperties
func (a DiscoveryResultDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedItemChannelLinkDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedItemChannelLinkDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedItemChannelLinkDTO_Configuration
func (a *EnrichedItemChannelLinkDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a *EnrichedItemChannelLinkDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a EnrichedItemChannelLinkDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedItemDTO_Metadata. Returns the specified
// element and whether it was found
func (a EnrichedItemDTO_Metadata) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedItemDTO_Metadata
func (a *EnrichedItemDTO_Metadata) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedItemDTO_Metadata to handle AdditionalProperties
func (a *EnrichedItemDTO_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedItemDTO_Metadata to handle AdditionalProperties
func (a EnrichedItemDTO_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedRuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedRuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedRuleDTO_Configuration
func (a *EnrichedRuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedRuleDTO_Configuration to handle AdditionalProperties
func (a *EnrichedRuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedRuleDTO_Configuration to handle AdditionalProperties
func (a EnrichedRuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedThingDTO_Configuration. Returns the specified
// element and whether it was found
func (a EnrichedThingDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedThingDTO_Configuration
func (a *EnrichedThingDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedThingDTO_Configuration to handle AdditionalProperties
func (a *EnrichedThingDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedThingDTO_Configuration to handle AdditionalProperties
func (a EnrichedThingDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EnrichedThingDTO_Properties. Returns the specified
// element and whether it was found
func (a EnrichedThingDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EnrichedThingDTO_Properties
func (a *EnrichedThingDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EnrichedThingDTO_Properties to handle AdditionalProperties
func (a *EnrichedThingDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EnrichedThingDTO_Properties to handle AdditionalProperties
func (a EnrichedThingDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ItemChannelLinkDTO_Configuration. Returns the specified
// element and whether it was found
func (a ItemChannelLinkDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ItemChannelLinkDTO_Configuration
func (a *ItemChannelLinkDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a *ItemChannelLinkDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ItemChannelLinkDTO_Configuration to handle AdditionalProperties
func (a ItemChannelLinkDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MetadataDTO_Config. Returns the specified
// element and whether it was found
func (a MetadataDTO_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MetadataDTO_Config
func (a *MetadataDTO_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MetadataDTO_Config to handle AdditionalProperties
func (a *MetadataDTO_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MetadataDTO_Config to handle AdditionalProperties
func (a MetadataDTO_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ModuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a ModuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ModuleDTO_Configuration
func (a *ModuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ModuleDTO_Configuration to handle AdditionalProperties
func (a *ModuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ModuleDTO_Configuration to handle AdditionalProperties
func (a ModuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RootUIComponent_Config. Returns the specified
// element and whether it was found
func (a RootUIComponent_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RootUIComponent_Config
func (a *RootUIComponent_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RootUIComponent_Config to handle AdditionalProperties
func (a *RootUIComponent_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RootUIComponent_Config to handle AdditionalProperties
func (a RootUIComponent_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RootUIComponent_Slots. Returns the specified
// element and whether it was found
func (a RootUIComponent_Slots) Get(fieldName string) (value []UIComponent, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RootUIComponent_Slots
func (a *RootUIComponent_Slots) Set(fieldName string, value []UIComponent) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]UIComponent)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RootUIComponent_Slots to handle AdditionalProperties
func (a *RootUIComponent_Slots) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]UIComponent)
		for fieldName, fieldBuf := range object {
			var fieldVal []UIComponent
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RootUIComponent_Slots to handle AdditionalProperties
func (a RootUIComponent_Slots) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RuleDTO_Configuration. Returns the specified
// element and whether it was found
func (a RuleDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RuleDTO_Configuration
func (a *RuleDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RuleDTO_Configuration to handle AdditionalProperties
func (a *RuleDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RuleDTO_Configuration to handle AdditionalProperties
func (a RuleDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingDTO_Configuration. Returns the specified
// element and whether it was found
func (a ThingDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingDTO_Configuration
func (a *ThingDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingDTO_Configuration to handle AdditionalProperties
func (a *ThingDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingDTO_Configuration to handle AdditionalProperties
func (a ThingDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingDTO_Properties. Returns the specified
// element and whether it was found
func (a ThingDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingDTO_Properties
func (a *ThingDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingDTO_Properties to handle AdditionalProperties
func (a *ThingDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingDTO_Properties to handle AdditionalProperties
func (a ThingDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ThingTypeDTO_Properties. Returns the specified
// element and whether it was found
func (a ThingTypeDTO_Properties) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ThingTypeDTO_Properties
func (a *ThingTypeDTO_Properties) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ThingTypeDTO_Properties to handle AdditionalProperties
func (a *ThingTypeDTO_Properties) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ThingTypeDTO_Properties to handle AdditionalProperties
func (a ThingTypeDTO_Properties) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TriggerDTO_Configuration. Returns the specified
// element and whether it was found
func (a TriggerDTO_Configuration) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TriggerDTO_Configuration
func (a *TriggerDTO_Configuration) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TriggerDTO_Configuration to handle AdditionalProperties
func (a *TriggerDTO_Configuration) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TriggerDTO_Configuration to handle AdditionalProperties
func (a TriggerDTO_Configuration) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UIComponent_Config. Returns the specified
// element and whether it was found
func (a UIComponent_Config) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UIComponent_Config
func (a *UIComponent_Config) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UIComponent_Config to handle AdditionalProperties
func (a *UIComponent_Config) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UIComponent_Config to handle AdditionalProperties
func (a UIComponent_Config) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetRoot request
	GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddons request
	GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonTypes request
	GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAddonFromURL request
	InstallAddonFromURL(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonById request
	GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAddonById request
	InstallAddonById(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallAddon request
	UninstallAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSink request
	GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSource request
	GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSinks request
	GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSources request
	GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiTokens request
	GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveApiToken request
	RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSession request with any body
	DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionsForCurrentUser request
	GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindings request
	GetBindings(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindingConfiguration request
	GetBindingConfiguration(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBindingConfiguration request with any body
	UpdateBindingConfigurationWithBody(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBindingConfiguration(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypes request
	GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypeByUID request
	GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkableItemTypesByChannelTypeUID request
	GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptions request
	GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptionByURI request
	GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindingsWithDiscoverySupport request
	GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Scan request
	Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitNewStateTacker request
	InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemListForStateUpdates request with any body
	UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIconSets request
	GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscoveredInboxItems request
	GetDiscoveredInboxItems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromInbox request
	RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveInboxItemById request with any body
	ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FlagInboxItemAsIgnored request
	FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveIgnoreFlagOnInboxItem request
	RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItems request
	GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemsInRegistry request with any body
	AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMemberFromGroupItem request
	RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMemberToGroupItem request
	AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromRegistry request
	RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemByName request
	GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendItemCommand request with any body
	SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemInRegistry request with any body
	AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMetadataFromItem request
	RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMetadataToItem request with any body
	AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemState request
	GetItemState(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemState request with any body
	UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagFromItem request
	RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTagToItem request
	AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLinks request
	GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkItemFromChannel request
	UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLink request
	GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkItemToChannel request with any body
	LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypes request
	GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypeById request
	GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistenceServices request
	GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemsForPersistenceService request
	GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItemFromPersistenceService request
	DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemDataFromPersistenceService request
	GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreItemDataInPersistenceService request
	StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfileTypes request
	GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRule request with any body
	CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduleRuleSimulations request
	GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleById request
	GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRule request with any body
	UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleActions request
	GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConditions request
	GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConfiguration request
	GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleConfiguration request with any body
	UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableRule request with any body
	EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunRuleNow request
	RunRuleNow(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleTriggers request
	GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleById request
	GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfig request
	GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfigParameter request
	GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRuleModuleConfigParameter request with any body
	SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesById request
	GetServicesById(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceConfig request
	DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceConfig request
	GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceConfig request with any body
	UpdateServiceConfigWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceConfig(ctx context.Context, serviceId string, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceContext request
	GetServiceContext(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemaps request
	GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSitemapEventSubscription request
	CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapEvents request
	GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapByName request
	GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollDataForSitemap request
	PollDataForSitemap(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInformation request
	GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateById request
	GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypes request
	GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypeById request
	GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThings request
	GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateThingInRegistry request with any body
	CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveThingById request
	RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingById request
	GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThing request with any body
	UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingConfig request with any body
	UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingConfigStatus request
	GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableThing request with any body
	EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingFirmwareStatus request
	GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingFirmware request
	UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableFirmwaresForThing request
	GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingStatus request
	GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegisteredUIComponentsInNamespace request
	GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUIComponentToNamespace request with any body
	AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUIComponentFromNamespace request
	RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUIComponentInNamespace request
	GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUIComponentInNamespace request with any body
	UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUITiles request
	GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUUID request
	GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultVoice request
	GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreters request
	GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretTextByDefaultInterpreter request with any body
	InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreterByUID request
	GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretText request with any body
	InterpretTextWithBody(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TextToSpeech request with any body
	TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoices request
	GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAddonFromURL(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAddonFromURLRequest(c.Server, url)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonByIdRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAddonById(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAddonByIdRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallAddon(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAddonRequest(c.Server, addonId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSourceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveApiTokenRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionsForCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindings(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindingConfiguration(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingConfigurationRequest(c.Server, bindingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBindingConfigurationWithBody(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBindingConfigurationRequestWithBody(c.Server, bindingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBindingConfiguration(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBindingConfigurationRequest(c.Server, bindingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypeByUIDRequest(c.Server, channelTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkableItemTypesByChannelTypeUIDRequest(c.Server, channelTypeUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionByURIRequest(c.Server, uri, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingsWithDiscoverySupportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanRequest(c.Server, bindingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitNewStateTackerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemListForStateUpdatesRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIconSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscoveredInboxItems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscoveredInboxItemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromInboxRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveInboxItemByIdRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFlagInboxItemAsIgnoredRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveIgnoreFlagOnInboxItemRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMemberFromGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMemberToGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromRegistryRequest(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemByNameRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendItemCommandRequestWithBody(c.Server, itemname, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequest(c.Server, itemname, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMetadataFromItemRequest(c.Server, itemname, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequestWithBody(c.Server, itemname, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequest(c.Server, itemname, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemState(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemStateRequest(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemStateRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagFromItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTagToItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkItemFromChannelRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinkRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkItemToChannelRequestWithBody(c.Server, itemName, channelUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypeByIdRequest(c.Server, moduleTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsForPersistenceServiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemDataFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreItemDataInPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRuleSimulationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleByIdRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleActionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConditionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConfigurationRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRuleNow(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRuleNowRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleTriggersRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleByIdRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigParameterRequest(c.Server, ruleUID, moduleCategory, id, param)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRuleModuleConfigParameterRequestWithBody(c.Server, ruleUID, moduleCategory, id, param, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesById(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesByIdRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfigWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfig(ctx context.Context, serviceId string, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceContext(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceContextRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSitemapEventSubscriptionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapEventsRequest(c.Server, subscriptionid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapByNameRequest(c.Server, sitemapname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollDataForSitemap(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollDataForSitemapRequest(c.Server, sitemapname, pageid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateByIdRequest(c.Server, templateUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypeByIdRequest(c.Server, thingTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingConfigStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingFirmwareStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingFirmwareRequest(c.Server, thingUID, firmwareVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableFirmwaresForThingRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegisteredUIComponentsInNamespaceRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUIComponentToNamespaceRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUIComponentFromNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUIComponentInNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUIComponentInNamespaceRequestWithBody(c.Server, namespace, componentUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUITilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUUIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultVoiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpretersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextByDefaultInterpreterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpreterByUIDRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextWithBody(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTextToSpeechRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRootRequest generates requests for GetRoot
func NewGetRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonsRequest generates requests for GetAddons
func NewGetAddonsRequest(server string, params *GetAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAddonTypesRequest generates requests for GetAddonTypes
func NewGetAddonTypesRequest(server string, params *GetAddonTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInstallAddonFromURLRequest generates requests for InstallAddonFromURL
func NewInstallAddonFromURLRequest(server string, url string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "url", runtime.ParamLocationPath, url)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/url/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonByIdRequest generates requests for GetAddonById
func NewGetAddonByIdRequest(server string, addonId string, params *GetAddonByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInstallAddonByIdRequest generates requests for InstallAddonById
func NewInstallAddonByIdRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallAddonRequest generates requests for UninstallAddon
func NewUninstallAddonRequest(server string, addonId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/uninstall", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioDefaultSinkRequest generates requests for GetAudioDefaultSink
func NewGetAudioDefaultSinkRequest(server string, params *GetAudioDefaultSinkParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioDefaultSourceRequest generates requests for GetAudioDefaultSource
func NewGetAudioDefaultSourceRequest(server string, params *GetAudioDefaultSourceParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsource")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioSinksRequest generates requests for GetAudioSinks
func NewGetAudioSinksRequest(server string, params *GetAudioSinksParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAudioSourcesRequest generates requests for GetAudioSources
func NewGetAudioSourcesRequest(server string, params *GetAudioSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetApiTokensRequest generates requests for GetApiTokens
func NewGetApiTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveApiTokenRequest generates requests for RemoveApiToken
func NewRemoveApiTokenRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSessionRequestWithBody generates requests for DeleteSession with any type of body
func NewDeleteSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSessionsForCurrentUserRequest generates requests for GetSessionsForCurrentUser
func NewGetSessionsForCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, params *GetOAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.UseCookie != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useCookie", runtime.ParamLocationQuery, *params.UseCookie); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBindingsRequest generates requests for GetBindings
func NewGetBindingsRequest(server string, params *GetBindingsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetBindingConfigurationRequest generates requests for GetBindingConfiguration
func NewGetBindingConfigurationRequest(server string, bindingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBindingConfigurationRequest calls the generic UpdateBindingConfiguration builder with application/json body
func NewUpdateBindingConfigurationRequest(server string, bindingId string, body UpdateBindingConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBindingConfigurationRequestWithBody(server, bindingId, "application/json", bodyReader)
}

// NewUpdateBindingConfigurationRequestWithBody generates requests for UpdateBindingConfiguration with any type of body
func NewUpdateBindingConfigurationRequestWithBody(server string, bindingId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bindings/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelTypesRequest generates requests for GetChannelTypes
func NewGetChannelTypesRequest(server string, params *GetChannelTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetChannelTypeByUIDRequest generates requests for GetChannelTypeByUID
func NewGetChannelTypeByUIDRequest(server string, channelTypeUID string, params *GetChannelTypeByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetLinkableItemTypesByChannelTypeUIDRequest generates requests for GetLinkableItemTypesByChannelTypeUID
func NewGetLinkableItemTypesByChannelTypeUIDRequest(server string, channelTypeUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s/linkableItemTypes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigDescriptionsRequest generates requests for GetConfigDescriptions
func NewGetConfigDescriptionsRequest(server string, params *GetConfigDescriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Scheme != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheme", runtime.ParamLocationQuery, *params.Scheme); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetConfigDescriptionByURIRequest generates requests for GetConfigDescriptionByURI
func NewGetConfigDescriptionByURIRequest(server string, uri string, params *GetConfigDescriptionByURIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uri", runtime.ParamLocationPath, uri)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetBindingsWithDiscoverySupportRequest generates requests for GetBindingsWithDiscoverySupport
func NewGetBindingsWithDiscoverySupportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScanRequest generates requests for Scan
func NewScanRequest(server string, bindingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/bindings/%s/scan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, params *GetEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Topics != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitNewStateTackerRequest generates requests for InitNewStateTacker
func NewInitNewStateTackerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemListForStateUpdatesRequestWithBody generates requests for UpdateItemListForStateUpdates with any type of body
func NewUpdateItemListForStateUpdatesRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIconSetsRequest generates requests for GetIconSets
func NewGetIconSetsRequest(server string, params *GetIconSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iconsets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetDiscoveredInboxItemsRequest generates requests for GetDiscoveredInboxItems
func NewGetDiscoveredInboxItemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveItemFromInboxRequest generates requests for RemoveItemFromInbox
func NewRemoveItemFromInboxRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveInboxItemByIdRequestWithBody generates requests for ApproveInboxItemById with any type of body
func NewApproveInboxItemByIdRequestWithBody(server string, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.NewThingId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newThingId", runtime.ParamLocationQuery, *params.NewThingId); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewFlagInboxItemAsIgnoredRequest generates requests for FlagInboxItemAsIgnored
func NewFlagInboxItemAsIgnoredRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/ignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveIgnoreFlagOnInboxItemRequest generates requests for RemoveIgnoreFlagOnInboxItem
func NewRemoveIgnoreFlagOnInboxItemRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/unignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemsRequest generates requests for GetItems
func NewGetItemsRequest(server string, params *GetItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Recursive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Fields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewAddOrUpdateItemsInRegistryRequest calls the generic AddOrUpdateItemsInRegistry builder with application/json body
func NewAddOrUpdateItemsInRegistryRequest(server string, body AddOrUpdateItemsInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemsInRegistryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrUpdateItemsInRegistryRequestWithBody generates requests for AddOrUpdateItemsInRegistry with any type of body
func NewAddOrUpdateItemsInRegistryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMemberFromGroupItemRequest generates requests for RemoveMemberFromGroupItem
func NewRemoveMemberFromGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMemberToGroupItemRequest generates requests for AddMemberToGroupItem
func NewAddMemberToGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveItemFromRegistryRequest generates requests for RemoveItemFromRegistry
func NewRemoveItemFromRegistryRequest(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemByNameRequest generates requests for GetItemByName
func NewGetItemByNameRequest(server string, itemname string, params *GetItemByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Metadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewSendItemCommandRequestWithBody generates requests for SendItemCommand with any type of body
func NewSendItemCommandRequestWithBody(server string, itemname string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOrUpdateItemInRegistryRequest calls the generic AddOrUpdateItemInRegistry builder with application/json body
func NewAddOrUpdateItemInRegistryRequest(server string, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemInRegistryRequestWithBody(server, itemname, params, "application/json", bodyReader)
}

// NewAddOrUpdateItemInRegistryRequestWithBody generates requests for AddOrUpdateItemInRegistry with any type of body
func NewAddOrUpdateItemInRegistryRequestWithBody(server string, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveMetadataFromItemRequest generates requests for RemoveMetadataFromItem
func NewRemoveMetadataFromItemRequest(server string, itemname string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMetadataToItemRequest calls the generic AddMetadataToItem builder with application/json body
func NewAddMetadataToItemRequest(server string, itemname string, namespace string, body AddMetadataToItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMetadataToItemRequestWithBody(server, itemname, namespace, "application/json", bodyReader)
}

// NewAddMetadataToItemRequestWithBody generates requests for AddMetadataToItem with any type of body
func NewAddMetadataToItemRequestWithBody(server string, itemname string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetItemStateRequest generates requests for GetItemState
func NewGetItemStateRequest(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemStateRequestWithBody generates requests for UpdateItemState with any type of body
func NewUpdateItemStateRequestWithBody(server string, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveTagFromItemRequest generates requests for RemoveTagFromItem
func NewRemoveTagFromItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTagToItemRequest generates requests for AddTagToItem
func NewAddTagToItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinksRequest generates requests for GetItemLinks
func NewGetItemLinksRequest(server string, params *GetItemLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.ChannelUID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelUID", runtime.ParamLocationQuery, *params.ChannelUID); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.ItemName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemName", runtime.ParamLocationQuery, *params.ItemName); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkItemFromChannelRequest generates requests for UnlinkItemFromChannel
func NewUnlinkItemFromChannelRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinkRequest generates requests for GetItemLink
func NewGetItemLinkRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkItemToChannelRequestWithBody generates requests for LinkItemToChannel with any type of body
func NewLinkItemToChannelRequestWithBody(server string, itemName string, channelUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetModuleTypesRequest generates requests for GetModuleTypes
func NewGetModuleTypesRequest(server string, params *GetModuleTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetModuleTypeByIdRequest generates requests for GetModuleTypeById
func NewGetModuleTypeByIdRequest(server string, moduleTypeUID string, params *GetModuleTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "moduleTypeUID", runtime.ParamLocationPath, moduleTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetPersistenceServicesRequest generates requests for GetPersistenceServices
func NewGetPersistenceServicesRequest(server string, params *GetPersistenceServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetItemsForPersistenceServiceRequest generates requests for GetItemsForPersistenceService
func NewGetItemsForPersistenceServiceRequest(server string, params *GetItemsForPersistenceServiceParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemFromPersistenceServiceRequest generates requests for DeleteItemFromPersistenceService
func NewDeleteItemFromPersistenceServiceRequest(server string, itemname string, params *DeleteItemFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, params.ServiceId); err != nil {
		return nil, err
	} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, params.Starttime); err != nil {
		return nil, err
	} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, params.Endtime); err != nil {
		return nil, err
	} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemDataFromPersistenceServiceRequest generates requests for GetItemDataFromPersistenceService
func NewGetItemDataFromPersistenceServiceRequest(server string, itemname string, params *GetItemDataFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Starttime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, *params.Starttime); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Endtime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, *params.Endtime); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Pagelength != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagelength", runtime.ParamLocationQuery, *params.Pagelength); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Boundary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boundary", runtime.ParamLocationQuery, *params.Boundary); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreItemDataInPersistenceServiceRequest generates requests for StoreItemDataInPersistenceService
func NewStoreItemDataInPersistenceServiceRequest(server string, itemname string, params *StoreItemDataInPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.ServiceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, params.Time); err != nil {
		return nil, err
	} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileTypesRequest generates requests for GetProfileTypes
func NewGetProfileTypesRequest(server string, params *GetProfileTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.ChannelTypeUID != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelTypeUID", runtime.ParamLocationQuery, *params.ChannelTypeUID); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.ItemType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemType", runtime.ParamLocationQuery, *params.ItemType); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScheduleRuleSimulationsRequest generates requests for GetScheduleRuleSimulations
func NewGetScheduleRuleSimulationsRequest(server string, params *GetScheduleRuleSimulationsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/schedule/simulations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Until != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleByIdRequest generates requests for GetRuleById
func NewGetRuleByIdRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, ruleUID string, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRuleActionsRequest generates requests for GetRuleActions
func NewGetRuleActionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConditionsRequest generates requests for GetRuleConditions
func NewGetRuleConditionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConfigurationRequest generates requests for GetRuleConfiguration
func NewGetRuleConfigurationRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleConfigurationRequest calls the generic UpdateRuleConfiguration builder with application/json body
func NewUpdateRuleConfigurationRequest(server string, ruleUID string, body UpdateRuleConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleConfigurationRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleConfigurationRequestWithBody generates requests for UpdateRuleConfiguration with any type of body
func NewUpdateRuleConfigurationRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableRuleRequestWithBody generates requests for EnableRule with any type of body
func NewEnableRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunRuleNowRequest generates requests for RunRuleNow
func NewRunRuleNowRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/runnow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleTriggersRequest generates requests for GetRuleTriggers
func NewGetRuleTriggersRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleByIdRequest generates requests for GetRuleModuleById
func NewGetRuleModuleByIdRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigRequest generates requests for GetRuleModuleConfig
func NewGetRuleModuleConfigRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigParameterRequest generates requests for GetRuleModuleConfigParameter
func NewGetRuleModuleConfigParameterRequest(server string, ruleUID string, moduleCategory string, id string, param string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRuleModuleConfigParameterRequestWithBody generates requests for SetRuleModuleConfigParameter with any type of body
func NewSetRuleModuleConfigParameterRequestWithBody(server string, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesByIdRequest generates requests for GetServicesById
func NewGetServicesByIdRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteServiceConfigRequest generates requests for DeleteServiceConfig
func NewDeleteServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceConfigRequest generates requests for GetServiceConfig
func NewGetServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceConfigRequest calls the generic UpdateServiceConfig builder with application/json body
func NewUpdateServiceConfigRequest(server string, serviceId string, body UpdateServiceConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceConfigRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewUpdateServiceConfigRequestWithBody generates requests for UpdateServiceConfig with any type of body
func NewUpdateServiceConfigRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceContextRequest generates requests for GetServiceContext
func NewGetServiceContextRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/contexts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapsRequest generates requests for GetSitemaps
func NewGetSitemapsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSitemapEventSubscriptionRequest generates requests for CreateSitemapEventSubscription
func NewCreateSitemapEventSubscriptionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapEventsRequest generates requests for GetSitemapEvents
func NewGetSitemapEventsRequest(server string, subscriptionid string, params *GetSitemapEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionid", runtime.ParamLocationPath, subscriptionid)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Sitemap != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitemap", runtime.ParamLocationQuery, *params.Sitemap); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Pageid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageid", runtime.ParamLocationQuery, *params.Pageid); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapByNameRequest generates requests for GetSitemapByName
func NewGetSitemapByNameRequest(server string, sitemapname string, params *GetSitemapByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Jsoncallback != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsoncallback", runtime.ParamLocationQuery, *params.Jsoncallback); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.IncludeHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewPollDataForSitemapRequest generates requests for PollDataForSitemap
func NewPollDataForSitemapRequest(server string, sitemapname string, pageid string, params *PollDataForSitemapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pageid", runtime.ParamLocationPath, pageid)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Subscriptionid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionid", runtime.ParamLocationQuery, *params.Subscriptionid); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.IncludeHidden != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetSystemInformationRequest generates requests for GetSystemInformation
func NewGetSystemInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systeminfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string, params *GetTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetTemplateByIdRequest generates requests for GetTemplateById
func NewGetTemplateByIdRequest(server string, templateUID string, params *GetTemplateByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateUID", runtime.ParamLocationPath, templateUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingTypesRequest generates requests for GetThingTypes
func NewGetThingTypesRequest(server string, params *GetThingTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.BindingId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bindingId", runtime.ParamLocationQuery, *params.BindingId); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingTypeByIdRequest generates requests for GetThingTypeById
func NewGetThingTypeByIdRequest(server string, thingTypeUID string, params *GetThingTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingTypeUID", runtime.ParamLocationPath, thingTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingsRequest generates requests for GetThings
func NewGetThingsRequest(server string, params *GetThingsParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewCreateThingInRegistryRequest calls the generic CreateThingInRegistry builder with application/json body
func NewCreateThingInRegistryRequest(server string, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateThingInRegistryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateThingInRegistryRequestWithBody generates requests for CreateThingInRegistry with any type of body
func NewCreateThingInRegistryRequestWithBody(server string, params *CreateThingInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewRemoveThingByIdRequest generates requests for RemoveThingById
func NewRemoveThingByIdRequest(server string, thingUID string, params *RemoveThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingByIdRequest generates requests for GetThingById
func NewGetThingByIdRequest(server string, thingUID string, params *GetThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingRequest calls the generic UpdateThing builder with application/json body
func NewUpdateThingRequest(server string, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingRequestWithBody generates requests for UpdateThing with any type of body
func NewUpdateThingRequestWithBody(server string, thingUID string, params *UpdateThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingConfigRequest calls the generic UpdateThingConfig builder with application/json body
func NewUpdateThingConfigRequest(server string, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingConfigRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingConfigRequestWithBody generates requests for UpdateThingConfig with any type of body
func NewUpdateThingConfigRequestWithBody(server string, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingConfigStatusRequest generates requests for GetThingConfigStatus
func NewGetThingConfigStatusRequest(server string, thingUID string, params *GetThingConfigStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewEnableThingRequestWithBody generates requests for EnableThing with any type of body
func NewEnableThingRequestWithBody(server string, thingUID string, params *EnableThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingFirmwareStatusRequest generates requests for GetThingFirmwareStatus
func NewGetThingFirmwareStatusRequest(server string, thingUID string, params *GetThingFirmwareStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewUpdateThingFirmwareRequest generates requests for UpdateThingFirmware
func NewUpdateThingFirmwareRequest(server string, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "firmwareVersion", runtime.ParamLocationPath, firmwareVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetAvailableFirmwaresForThingRequest generates requests for GetAvailableFirmwaresForThing
func NewGetAvailableFirmwaresForThingRequest(server string, thingUID string, params *GetAvailableFirmwaresForThingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmwares", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetThingStatusRequest generates requests for GetThingStatus
func NewGetThingStatusRequest(server string, thingUID string, params *GetThingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetRegisteredUIComponentsInNamespaceRequest generates requests for GetRegisteredUIComponentsInNamespace
func NewGetRegisteredUIComponentsInNamespaceRequest(server string, namespace string, params *GetRegisteredUIComponentsInNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Summary != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUIComponentToNamespaceRequestWithBody generates requests for AddUIComponentToNamespace with any type of body
func NewAddUIComponentToNamespaceRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUIComponentFromNamespaceRequest generates requests for RemoveUIComponentFromNamespace
func NewRemoveUIComponentFromNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUIComponentInNamespaceRequest generates requests for GetUIComponentInNamespace
func NewGetUIComponentInNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUIComponentInNamespaceRequestWithBody generates requests for UpdateUIComponentInNamespace with any type of body
func NewUpdateUIComponentInNamespaceRequestWithBody(server string, namespace string, componentUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUITilesRequest generates requests for GetUITiles
func NewGetUITilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/tiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUUIDRequest generates requests for GetUUID
func NewGetUUIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uuid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultVoiceRequest generates requests for GetDefaultVoice
func NewGetDefaultVoiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/defaultvoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceInterpretersRequest generates requests for GetVoiceInterpreters
func NewGetVoiceInterpretersRequest(server string, params *GetVoiceInterpretersParams) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInterpretTextByDefaultInterpreterRequestWithBody generates requests for InterpretTextByDefaultInterpreter with any type of body
func NewInterpretTextByDefaultInterpreterRequestWithBody(server string, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewGetVoiceInterpreterByUIDRequest generates requests for GetVoiceInterpreterByUID
func NewGetVoiceInterpreterByUIDRequest(server string, id string, params *GetVoiceInterpreterByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewInterpretTextRequestWithBody generates requests for InterpretText with any type of body
func NewInterpretTextRequestWithBody(server string, id string, params *InterpretTextParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil && params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewTextToSpeechRequestWithBody generates requests for TextToSpeech with any type of body
func NewTextToSpeechRequestWithBody(server string, params *TextToSpeechParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/say")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params != nil && params.Voiceid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voiceid", runtime.ParamLocationQuery, *params.Voiceid); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params != nil && params.Sinkid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinkid", runtime.ParamLocationQuery, *params.Sinkid); err != nil {
			return nil, err
		} else if parsed, err := originalURL.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVoicesRequest generates requests for GetVoices
func NewGetVoicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := originalURL.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/voices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetRoot request
	GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error)

	// GetAddons request
	GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error)

	// GetAddonTypes request
	GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error)

	// InstallAddonFromURL request
	InstallAddonFromURLWithResponse(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*InstallAddonFromURLResponse, error)

	// GetAddonById request
	GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error)

	// InstallAddonById request
	InstallAddonByIdWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error)

	// UninstallAddon request
	UninstallAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error)

	// GetAudioDefaultSink request
	GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error)

	// GetAudioDefaultSource request
	GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error)

	// GetAudioSinks request
	GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error)

	// GetAudioSources request
	GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error)

	// GetApiTokens request
	GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error)

	// RemoveApiToken request
	RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error)

	// DeleteSession request with any body
	DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error)

	// GetSessionsForCurrentUser request
	GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// GetBindings request
	GetBindingsWithResponse(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*GetBindingsResponse, error)

	// GetBindingConfiguration request
	GetBindingConfigurationWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*GetBindingConfigurationResponse, error)

	// UpdateBindingConfiguration request with any body
	UpdateBindingConfigurationWithBodyWithResponse(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error)

	UpdateBindingConfigurationWithResponse(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error)

	// GetChannelTypes request
	GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error)

	// GetChannelTypeByUID request
	GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error)

	// GetLinkableItemTypesByChannelTypeUID request
	GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error)

	// GetConfigDescriptions request
	GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error)

	// GetConfigDescriptionByURI request
	GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error)

	// GetBindingsWithDiscoverySupport request
	GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error)

	// Scan request
	ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error)

	// GetEvents request
	GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)

	// InitNewStateTacker request
	InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error)

	// UpdateItemListForStateUpdates request with any body
	UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error)

	// GetIconSets request
	GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error)

	// GetDiscoveredInboxItems request
	GetDiscoveredInboxItemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error)

	// RemoveItemFromInbox request
	RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error)

	// ApproveInboxItemById request with any body
	ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error)

	// FlagInboxItemAsIgnored request
	FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error)

	// RemoveIgnoreFlagOnInboxItem request
	RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error)

	// GetItems request
	GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error)

	// AddOrUpdateItemsInRegistry request with any body
	AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	// RemoveMemberFromGroupItem request
	RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error)

	// AddMemberToGroupItem request
	AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error)

	// RemoveItemFromRegistry request
	RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error)

	// GetItemByName request
	GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error)

	// SendItemCommand request with any body
	SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error)

	// AddOrUpdateItemInRegistry request with any body
	AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	// RemoveMetadataFromItem request
	RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error)

	// AddMetadataToItem request with any body
	AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	// GetItemState request
	GetItemStateWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemStateResponse, error)

	// UpdateItemState request with any body
	UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error)

	// RemoveTagFromItem request
	RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error)

	// AddTagToItem request
	AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error)

	// GetItemLinks request
	GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error)

	// UnlinkItemFromChannel request
	UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error)

	// GetItemLink request
	GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error)

	// LinkItemToChannel request with any body
	LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error)

	// GetModuleTypes request
	GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error)

	// GetModuleTypeById request
	GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error)

	// GetPersistenceServices request
	GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error)

	// GetItemsForPersistenceService request
	GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error)

	// DeleteItemFromPersistenceService request
	DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error)

	// GetItemDataFromPersistenceService request
	GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error)

	// StoreItemDataInPersistenceService request
	StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error)

	// GetProfileTypes request
	GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error)

	// GetRules request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// CreateRule request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// GetScheduleRuleSimulations request
	GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error)

	// DeleteRule request
	DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleById request
	GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error)

	// UpdateRule request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// GetRuleActions request
	GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error)

	// GetRuleConditions request
	GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error)

	// GetRuleConfiguration request
	GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error)

	// UpdateRuleConfiguration request with any body
	UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	// EnableRule request with any body
	EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error)

	// RunRuleNow request
	RunRuleNowWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*RunRuleNowResponse, error)

	// GetRuleTriggers request
	GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error)

	// GetRuleModuleById request
	GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error)

	// GetRuleModuleConfig request
	GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error)

	// GetRuleModuleConfigParameter request
	GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error)

	// SetRuleModuleConfigParameter request with any body
	SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error)

	// GetServices request
	GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// GetServicesById request
	GetServicesByIdWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error)

	// DeleteServiceConfig request
	DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error)

	// GetServiceConfig request
	GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error)

	// UpdateServiceConfig request with any body
	UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	// GetServiceContext request
	GetServiceContextWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error)

	// GetSitemaps request
	GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error)

	// CreateSitemapEventSubscription request
	CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error)

	// GetSitemapEvents request
	GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error)

	// GetSitemapByName request
	GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error)

	// PollDataForSitemap request
	PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error)

	// GetSystemInformation request
	GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error)

	// GetTemplates request
	GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error)

	// GetTemplateById request
	GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error)

	// GetThingTypes request
	GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error)

	// GetThingTypeById request
	GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error)

	// GetThings request
	GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error)

	// CreateThingInRegistry request with any body
	CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	// RemoveThingById request
	RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error)

	// GetThingById request
	GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error)

	// UpdateThing request with any body
	UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	// UpdateThingConfig request with any body
	UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	// GetThingConfigStatus request
	GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error)

	// EnableThing request with any body
	EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error)

	// GetThingFirmwareStatus request
	GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error)

	// UpdateThingFirmware request
	UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error)

	// GetAvailableFirmwaresForThing request
	GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error)

	// GetThingStatus request
	GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error)

	// GetRegisteredUIComponentsInNamespace request
	GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error)

	// AddUIComponentToNamespace request with any body
	AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error)

	// RemoveUIComponentFromNamespace request
	RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error)

	// GetUIComponentInNamespace request
	GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error)

	// UpdateUIComponentInNamespace request with any body
	UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error)

	// GetUITiles request
	GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error)

	// GetUUID request
	GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error)

	// GetDefaultVoice request
	GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error)

	// GetVoiceInterpreters request
	GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error)

	// InterpretTextByDefaultInterpreter request with any body
	InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error)

	// GetVoiceInterpreterByUID request
	GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error)

	// InterpretText request with any body
	InterpretTextWithBodyWithResponse(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error)

	// TextToSpeech request with any body
	TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error)

	// GetVoices request
	GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error)
}

type GetRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootBean
}

// Status returns HTTPResponse.Status
func (r GetRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddonType
}

// Status returns HTTPResponse.Status
func (r GetAddonTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAddonFromURLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallAddonFromURLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAddonFromURLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UninstallAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserApiTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveApiTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveApiTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveApiTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionsForCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserSessionDTO
}

// Status returns HTTPResponse.Status
func (r GetSessionsForCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionsForCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseDTO
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BindingInfoDTO
}

// Status returns HTTPResponse.Status
func (r GetBindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetBindingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBindingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateBindingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBindingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypeByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypeByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypeByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkableItemTypesByChannelTypeUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetLinkableItemTypesByChannelTypeUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkableItemTypesByChannelTypeUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionByURIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionByURIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionByURIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingsWithDiscoverySupportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetBindingsWithDiscoverySupportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingsWithDiscoverySupportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitNewStateTackerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InitNewStateTackerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitNewStateTackerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemListForStateUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemListForStateUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemListForStateUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIconSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IconSet
}

// Status returns HTTPResponse.Status
func (r GetIconSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIconSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscoveredInboxItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiscoveryResultDTO
}

// Status returns HTTPResponse.Status
func (r GetDiscoveredInboxItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscoveredInboxItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromInboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromInboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromInboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveInboxItemByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApproveInboxItemByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveInboxItemByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FlagInboxItemAsIgnoredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FlagInboxItemAsIgnoredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FlagInboxItemAsIgnoredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveIgnoreFlagOnInboxItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveIgnoreFlagOnInboxItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveIgnoreFlagOnInboxItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemsInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemsInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemsInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMemberFromGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMemberFromGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMemberFromGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMemberToGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMemberToGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMemberToGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendItemCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendItemCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendItemCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMetadataFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMetadataFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMetadataFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMetadataToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMetadataToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMetadataToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetItemStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveTagFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTagToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddTagToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTagToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemChannelLinkDTO
}

// Status returns HTTPResponse.Status
func (r GetItemLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkItemFromChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkItemFromChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkItemFromChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetItemLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkItemToChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkItemToChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkItemToChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetPersistenceServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsForPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceItemInfo
}

// Status returns HTTPResponse.Status
func (r GetItemsForPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsForPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteItemFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemDataFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemHistoryDTO
}

// Status returns HTTPResponse.Status
func (r GetItemDataFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemDataFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreItemDataInPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StoreItemDataInPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreItemDataInPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProfileTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetProfileTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleRuleSimulationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RuleExecution
}

// Status returns HTTPResponse.Status
func (r GetScheduleRuleSimulationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleRuleSimulationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConditionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunRuleNowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunRuleNowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunRuleNowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TriggerDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServiceContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSitemapEventSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSitemapEventSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSitemapEventSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSitemapEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollDataForSitemapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageDTO
}

// Status returns HTTPResponse.Status
func (r PollDataForSitemapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollDataForSitemapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfoBean
}

// Status returns HTTPResponse.Status
func (r GetSystemInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StrippedThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateThingInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateThingInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateThingInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingConfigStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigStatusMessage
}

// Status returns HTTPResponse.Status
func (r GetThingConfigStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingConfigStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingFirmwareStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetThingFirmwareStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingFirmwareStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingFirmwareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingFirmwareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingFirmwareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableFirmwaresForThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FirmwareDTO
}

// Status returns HTTPResponse.Status
func (r GetAvailableFirmwaresForThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableFirmwaresForThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingStatusInfo
}

// Status returns HTTPResponse.Status
func (r GetThingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegisteredUIComponentsInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetRegisteredUIComponentsInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegisteredUIComponentsInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUIComponentToNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r AddUIComponentToNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUIComponentToNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUIComponentFromNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUIComponentFromNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUIComponentFromNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r UpdateUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUITilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TileDTO
}

// Status returns HTTPResponse.Status
func (r GetUITilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUITilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultVoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetDefaultVoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultVoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpretersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpretersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpretersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextByDefaultInterpreterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextByDefaultInterpreterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextByDefaultInterpreterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpreterByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpreterByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpreterByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TextToSpeechResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TextToSpeechResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TextToSpeechResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetVoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetRootWithResponse request returning *GetRootResponse
func (c *ClientWithResponses) GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error) {
	rsp, err := c.GetRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootResponse(rsp)
}

// GetAddonsWithResponse request returning *GetAddonsResponse
func (c *ClientWithResponses) GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error) {
	rsp, err := c.GetAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonsResponse(rsp)
}

// GetAddonTypesWithResponse request returning *GetAddonTypesResponse
func (c *ClientWithResponses) GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error) {
	rsp, err := c.GetAddonTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonTypesResponse(rsp)
}

// InstallAddonFromURLWithResponse request returning *InstallAddonFromURLResponse
func (c *ClientWithResponses) InstallAddonFromURLWithResponse(ctx context.Context, url string, reqEditors ...RequestEditorFn) (*InstallAddonFromURLResponse, error) {
	rsp, err := c.InstallAddonFromURL(ctx, url, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAddonFromURLResponse(rsp)
}

// GetAddonByIdWithResponse request returning *GetAddonByIdResponse
func (c *ClientWithResponses) GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error) {
	rsp, err := c.GetAddonById(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonByIdResponse(rsp)
}

// InstallAddonByIdWithResponse request returning *InstallAddonByIdResponse
func (c *ClientWithResponses) InstallAddonByIdWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error) {
	rsp, err := c.InstallAddonById(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAddonByIdResponse(rsp)
}

// UninstallAddonWithResponse request returning *UninstallAddonResponse
func (c *ClientWithResponses) UninstallAddonWithResponse(ctx context.Context, addonId string, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error) {
	rsp, err := c.UninstallAddon(ctx, addonId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAddonResponse(rsp)
}

// GetAudioDefaultSinkWithResponse request returning *GetAudioDefaultSinkResponse
func (c *ClientWithResponses) GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error) {
	rsp, err := c.GetAudioDefaultSink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSinkResponse(rsp)
}

// GetAudioDefaultSourceWithResponse request returning *GetAudioDefaultSourceResponse
func (c *ClientWithResponses) GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error) {
	rsp, err := c.GetAudioDefaultSource(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSourceResponse(rsp)
}

// GetAudioSinksWithResponse request returning *GetAudioSinksResponse
func (c *ClientWithResponses) GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error) {
	rsp, err := c.GetAudioSinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSinksResponse(rsp)
}

// GetAudioSourcesWithResponse request returning *GetAudioSourcesResponse
func (c *ClientWithResponses) GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error) {
	rsp, err := c.GetAudioSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSourcesResponse(rsp)
}

// GetApiTokensWithResponse request returning *GetApiTokensResponse
func (c *ClientWithResponses) GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error) {
	rsp, err := c.GetApiTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiTokensResponse(rsp)
}

// RemoveApiTokenWithResponse request returning *RemoveApiTokenResponse
func (c *ClientWithResponses) RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error) {
	rsp, err := c.RemoveApiToken(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveApiTokenResponse(rsp)
}

// DeleteSessionWithBodyWithResponse request with arbitrary body returning *DeleteSessionResponse
func (c *ClientWithResponses) DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error) {
	rsp, err := c.DeleteSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionResponse(rsp)
}

// GetSessionsForCurrentUserWithResponse request returning *GetSessionsForCurrentUserResponse
func (c *ClientWithResponses) GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error) {
	rsp, err := c.GetSessionsForCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionsForCurrentUserResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// GetBindingsWithResponse request returning *GetBindingsResponse
func (c *ClientWithResponses) GetBindingsWithResponse(ctx context.Context, params *GetBindingsParams, reqEditors ...RequestEditorFn) (*GetBindingsResponse, error) {
	rsp, err := c.GetBindings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingsResponse(rsp)
}

// GetBindingConfigurationWithResponse request returning *GetBindingConfigurationResponse
func (c *ClientWithResponses) GetBindingConfigurationWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*GetBindingConfigurationResponse, error) {
	rsp, err := c.GetBindingConfiguration(ctx, bindingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingConfigurationResponse(rsp)
}

// UpdateBindingConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateBindingConfigurationResponse
func (c *ClientWithResponses) UpdateBindingConfigurationWithBodyWithResponse(ctx context.Context, bindingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error) {
	rsp, err := c.UpdateBindingConfigurationWithBody(ctx, bindingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBindingConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateBindingConfigurationWithResponse(ctx context.Context, bindingId string, body UpdateBindingConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBindingConfigurationResponse, error) {
	rsp, err := c.UpdateBindingConfiguration(ctx, bindingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBindingConfigurationResponse(rsp)
}

// GetChannelTypesWithResponse request returning *GetChannelTypesResponse
func (c *ClientWithResponses) GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error) {
	rsp, err := c.GetChannelTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypesResponse(rsp)
}

// GetChannelTypeByUIDWithResponse request returning *GetChannelTypeByUIDResponse
func (c *ClientWithResponses) GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error) {
	rsp, err := c.GetChannelTypeByUID(ctx, channelTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypeByUIDResponse(rsp)
}

// GetLinkableItemTypesByChannelTypeUIDWithResponse request returning *GetLinkableItemTypesByChannelTypeUIDResponse
func (c *ClientWithResponses) GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	rsp, err := c.GetLinkableItemTypesByChannelTypeUID(ctx, channelTypeUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp)
}

// GetConfigDescriptionsWithResponse request returning *GetConfigDescriptionsResponse
func (c *ClientWithResponses) GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error) {
	rsp, err := c.GetConfigDescriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionsResponse(rsp)
}

// GetConfigDescriptionByURIWithResponse request returning *GetConfigDescriptionByURIResponse
func (c *ClientWithResponses) GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error) {
	rsp, err := c.GetConfigDescriptionByURI(ctx, uri, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionByURIResponse(rsp)
}

// GetBindingsWithDiscoverySupportWithResponse request returning *GetBindingsWithDiscoverySupportResponse
func (c *ClientWithResponses) GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error) {
	rsp, err := c.GetBindingsWithDiscoverySupport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingsWithDiscoverySupportResponse(rsp)
}

// ScanWithResponse request returning *ScanResponse
func (c *ClientWithResponses) ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error) {
	rsp, err := c.Scan(ctx, bindingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// InitNewStateTackerWithResponse request returning *InitNewStateTackerResponse
func (c *ClientWithResponses) InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error) {
	rsp, err := c.InitNewStateTacker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitNewStateTackerResponse(rsp)
}

// UpdateItemListForStateUpdatesWithBodyWithResponse request with arbitrary body returning *UpdateItemListForStateUpdatesResponse
func (c *ClientWithResponses) UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error) {
	rsp, err := c.UpdateItemListForStateUpdatesWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemListForStateUpdatesResponse(rsp)
}

// GetIconSetsWithResponse request returning *GetIconSetsResponse
func (c *ClientWithResponses) GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error) {
	rsp, err := c.GetIconSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIconSetsResponse(rsp)
}

// GetDiscoveredInboxItemsWithResponse request returning *GetDiscoveredInboxItemsResponse
func (c *ClientWithResponses) GetDiscoveredInboxItemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error) {
	rsp, err := c.GetDiscoveredInboxItems(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscoveredInboxItemsResponse(rsp)
}

// RemoveItemFromInboxWithResponse request returning *RemoveItemFromInboxResponse
func (c *ClientWithResponses) RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error) {
	rsp, err := c.RemoveItemFromInbox(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromInboxResponse(rsp)
}

// ApproveInboxItemByIdWithBodyWithResponse request with arbitrary body returning *ApproveInboxItemByIdResponse
func (c *ClientWithResponses) ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error) {
	rsp, err := c.ApproveInboxItemByIdWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveInboxItemByIdResponse(rsp)
}

// FlagInboxItemAsIgnoredWithResponse request returning *FlagInboxItemAsIgnoredResponse
func (c *ClientWithResponses) FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error) {
	rsp, err := c.FlagInboxItemAsIgnored(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFlagInboxItemAsIgnoredResponse(rsp)
}

// RemoveIgnoreFlagOnInboxItemWithResponse request returning *RemoveIgnoreFlagOnInboxItemResponse
func (c *ClientWithResponses) RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	rsp, err := c.RemoveIgnoreFlagOnInboxItem(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveIgnoreFlagOnInboxItemResponse(rsp)
}

// GetItemsWithResponse request returning *GetItemsResponse
func (c *ClientWithResponses) GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error) {
	rsp, err := c.GetItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsResponse(rsp)
}

// AddOrUpdateItemsInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemsInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

// RemoveMemberFromGroupItemWithResponse request returning *RemoveMemberFromGroupItemResponse
func (c *ClientWithResponses) RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error) {
	rsp, err := c.RemoveMemberFromGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMemberFromGroupItemResponse(rsp)
}

// AddMemberToGroupItemWithResponse request returning *AddMemberToGroupItemResponse
func (c *ClientWithResponses) AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error) {
	rsp, err := c.AddMemberToGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMemberToGroupItemResponse(rsp)
}

// RemoveItemFromRegistryWithResponse request returning *RemoveItemFromRegistryResponse
func (c *ClientWithResponses) RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error) {
	rsp, err := c.RemoveItemFromRegistry(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromRegistryResponse(rsp)
}

// GetItemByNameWithResponse request returning *GetItemByNameResponse
func (c *ClientWithResponses) GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error) {
	rsp, err := c.GetItemByName(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemByNameResponse(rsp)
}

// SendItemCommandWithBodyWithResponse request with arbitrary body returning *SendItemCommandResponse
func (c *ClientWithResponses) SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error) {
	rsp, err := c.SendItemCommandWithBody(ctx, itemname, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendItemCommandResponse(rsp)
}

// AddOrUpdateItemInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistryWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistry(ctx, itemname, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

// RemoveMetadataFromItemWithResponse request returning *RemoveMetadataFromItemResponse
func (c *ClientWithResponses) RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error) {
	rsp, err := c.RemoveMetadataFromItem(ctx, itemname, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMetadataFromItemResponse(rsp)
}

// AddMetadataToItemWithBodyWithResponse request with arbitrary body returning *AddMetadataToItemResponse
func (c *ClientWithResponses) AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItemWithBody(ctx, itemname, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

func (c *ClientWithResponses) AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItem(ctx, itemname, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

// GetItemStateWithResponse request returning *GetItemStateResponse
func (c *ClientWithResponses) GetItemStateWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemStateResponse, error) {
	rsp, err := c.GetItemState(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemStateResponse(rsp)
}

// UpdateItemStateWithBodyWithResponse request with arbitrary body returning *UpdateItemStateResponse
func (c *ClientWithResponses) UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error) {
	rsp, err := c.UpdateItemStateWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemStateResponse(rsp)
}

// RemoveTagFromItemWithResponse request returning *RemoveTagFromItemResponse
func (c *ClientWithResponses) RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error) {
	rsp, err := c.RemoveTagFromItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagFromItemResponse(rsp)
}

// AddTagToItemWithResponse request returning *AddTagToItemResponse
func (c *ClientWithResponses) AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error) {
	rsp, err := c.AddTagToItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTagToItemResponse(rsp)
}

// GetItemLinksWithResponse request returning *GetItemLinksResponse
func (c *ClientWithResponses) GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error) {
	rsp, err := c.GetItemLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinksResponse(rsp)
}

// UnlinkItemFromChannelWithResponse request returning *UnlinkItemFromChannelResponse
func (c *ClientWithResponses) UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error) {
	rsp, err := c.UnlinkItemFromChannel(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkItemFromChannelResponse(rsp)
}

// GetItemLinkWithResponse request returning *GetItemLinkResponse
func (c *ClientWithResponses) GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error) {
	rsp, err := c.GetItemLink(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinkResponse(rsp)
}

// LinkItemToChannelWithBodyWithResponse request with arbitrary body returning *LinkItemToChannelResponse
func (c *ClientWithResponses) LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error) {
	rsp, err := c.LinkItemToChannelWithBody(ctx, itemName, channelUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkItemToChannelResponse(rsp)
}

// GetModuleTypesWithResponse request returning *GetModuleTypesResponse
func (c *ClientWithResponses) GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error) {
	rsp, err := c.GetModuleTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypesResponse(rsp)
}

// GetModuleTypeByIdWithResponse request returning *GetModuleTypeByIdResponse
func (c *ClientWithResponses) GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error) {
	rsp, err := c.GetModuleTypeById(ctx, moduleTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypeByIdResponse(rsp)
}

// GetPersistenceServicesWithResponse request returning *GetPersistenceServicesResponse
func (c *ClientWithResponses) GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error) {
	rsp, err := c.GetPersistenceServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceServicesResponse(rsp)
}

// GetItemsForPersistenceServiceWithResponse request returning *GetItemsForPersistenceServiceResponse
func (c *ClientWithResponses) GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error) {
	rsp, err := c.GetItemsForPersistenceService(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsForPersistenceServiceResponse(rsp)
}

// DeleteItemFromPersistenceServiceWithResponse request returning *DeleteItemFromPersistenceServiceResponse
func (c *ClientWithResponses) DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error) {
	rsp, err := c.DeleteItemFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemFromPersistenceServiceResponse(rsp)
}

// GetItemDataFromPersistenceServiceWithResponse request returning *GetItemDataFromPersistenceServiceResponse
func (c *ClientWithResponses) GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error) {
	rsp, err := c.GetItemDataFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemDataFromPersistenceServiceResponse(rsp)
}

// StoreItemDataInPersistenceServiceWithResponse request returning *StoreItemDataInPersistenceServiceResponse
func (c *ClientWithResponses) StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error) {
	rsp, err := c.StoreItemDataInPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreItemDataInPersistenceServiceResponse(rsp)
}

// GetProfileTypesWithResponse request returning *GetProfileTypesResponse
func (c *ClientWithResponses) GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error) {
	rsp, err := c.GetProfileTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileTypesResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// GetScheduleRuleSimulationsWithResponse request returning *GetScheduleRuleSimulationsResponse
func (c *ClientWithResponses) GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error) {
	rsp, err := c.GetScheduleRuleSimulations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleRuleSimulationsResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleByIdWithResponse request returning *GetRuleByIdResponse
func (c *ClientWithResponses) GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error) {
	rsp, err := c.GetRuleById(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleByIdResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// GetRuleActionsWithResponse request returning *GetRuleActionsResponse
func (c *ClientWithResponses) GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error) {
	rsp, err := c.GetRuleActions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleActionsResponse(rsp)
}

// GetRuleConditionsWithResponse request returning *GetRuleConditionsResponse
func (c *ClientWithResponses) GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error) {
	rsp, err := c.GetRuleConditions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConditionsResponse(rsp)
}

// GetRuleConfigurationWithResponse request returning *GetRuleConfigurationResponse
func (c *ClientWithResponses) GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error) {
	rsp, err := c.GetRuleConfiguration(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConfigurationResponse(rsp)
}

// UpdateRuleConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateRuleConfigurationResponse
func (c *ClientWithResponses) UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfigurationWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfiguration(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

// EnableRuleWithBodyWithResponse request with arbitrary body returning *EnableRuleResponse
func (c *ClientWithResponses) EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error) {
	rsp, err := c.EnableRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableRuleResponse(rsp)
}

// RunRuleNowWithResponse request returning *RunRuleNowResponse
func (c *ClientWithResponses) RunRuleNowWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*RunRuleNowResponse, error) {
	rsp, err := c.RunRuleNow(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRuleNowResponse(rsp)
}

// GetRuleTriggersWithResponse request returning *GetRuleTriggersResponse
func (c *ClientWithResponses) GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error) {
	rsp, err := c.GetRuleTriggers(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleTriggersResponse(rsp)
}

// GetRuleModuleByIdWithResponse request returning *GetRuleModuleByIdResponse
func (c *ClientWithResponses) GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error) {
	rsp, err := c.GetRuleModuleById(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleByIdResponse(rsp)
}

// GetRuleModuleConfigWithResponse request returning *GetRuleModuleConfigResponse
func (c *ClientWithResponses) GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error) {
	rsp, err := c.GetRuleModuleConfig(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigResponse(rsp)
}

// GetRuleModuleConfigParameterWithResponse request returning *GetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.GetRuleModuleConfigParameter(ctx, ruleUID, moduleCategory, id, param, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigParameterResponse(rsp)
}

// SetRuleModuleConfigParameterWithBodyWithResponse request with arbitrary body returning *SetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.SetRuleModuleConfigParameterWithBody(ctx, ruleUID, moduleCategory, id, param, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRuleModuleConfigParameterResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// GetServicesByIdWithResponse request returning *GetServicesByIdResponse
func (c *ClientWithResponses) GetServicesByIdWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error) {
	rsp, err := c.GetServicesById(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesByIdResponse(rsp)
}

// DeleteServiceConfigWithResponse request returning *DeleteServiceConfigResponse
func (c *ClientWithResponses) DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error) {
	rsp, err := c.DeleteServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceConfigResponse(rsp)
}

// GetServiceConfigWithResponse request returning *GetServiceConfigResponse
func (c *ClientWithResponses) GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error) {
	rsp, err := c.GetServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceConfigResponse(rsp)
}

// UpdateServiceConfigWithBodyWithResponse request with arbitrary body returning *UpdateServiceConfigResponse
func (c *ClientWithResponses) UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfigWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfig(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

// GetServiceContextWithResponse request returning *GetServiceContextResponse
func (c *ClientWithResponses) GetServiceContextWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error) {
	rsp, err := c.GetServiceContext(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceContextResponse(rsp)
}

// GetSitemapsWithResponse request returning *GetSitemapsResponse
func (c *ClientWithResponses) GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error) {
	rsp, err := c.GetSitemaps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapsResponse(rsp)
}

// CreateSitemapEventSubscriptionWithResponse request returning *CreateSitemapEventSubscriptionResponse
func (c *ClientWithResponses) CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error) {
	rsp, err := c.CreateSitemapEventSubscription(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSitemapEventSubscriptionResponse(rsp)
}

// GetSitemapEventsWithResponse request returning *GetSitemapEventsResponse
func (c *ClientWithResponses) GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error) {
	rsp, err := c.GetSitemapEvents(ctx, subscriptionid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapEventsResponse(rsp)
}

// GetSitemapByNameWithResponse request returning *GetSitemapByNameResponse
func (c *ClientWithResponses) GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error) {
	rsp, err := c.GetSitemapByName(ctx, sitemapname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapByNameResponse(rsp)
}

// PollDataForSitemapWithResponse request returning *PollDataForSitemapResponse
func (c *ClientWithResponses) PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error) {
	rsp, err := c.PollDataForSitemap(ctx, sitemapname, pageid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollDataForSitemapResponse(rsp)
}

// GetSystemInformationWithResponse request returning *GetSystemInformationResponse
func (c *ClientWithResponses) GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error) {
	rsp, err := c.GetSystemInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInformationResponse(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResponse
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error) {
	rsp, err := c.GetTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResponse(rsp)
}

// GetTemplateByIdWithResponse request returning *GetTemplateByIdResponse
func (c *ClientWithResponses) GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error) {
	rsp, err := c.GetTemplateById(ctx, templateUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateByIdResponse(rsp)
}

// GetThingTypesWithResponse request returning *GetThingTypesResponse
func (c *ClientWithResponses) GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error) {
	rsp, err := c.GetThingTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypesResponse(rsp)
}

// GetThingTypeByIdWithResponse request returning *GetThingTypeByIdResponse
func (c *ClientWithResponses) GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error) {
	rsp, err := c.GetThingTypeById(ctx, thingTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypeByIdResponse(rsp)
}

// GetThingsWithResponse request returning *GetThingsResponse
func (c *ClientWithResponses) GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error) {
	rsp, err := c.GetThings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingsResponse(rsp)
}

// CreateThingInRegistryWithBodyWithResponse request with arbitrary body returning *CreateThingInRegistryResponse
func (c *ClientWithResponses) CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

func (c *ClientWithResponses) CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

// RemoveThingByIdWithResponse request returning *RemoveThingByIdResponse
func (c *ClientWithResponses) RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error) {
	rsp, err := c.RemoveThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveThingByIdResponse(rsp)
}

// GetThingByIdWithResponse request returning *GetThingByIdResponse
func (c *ClientWithResponses) GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error) {
	rsp, err := c.GetThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingByIdResponse(rsp)
}

// UpdateThingWithBodyWithResponse request with arbitrary body returning *UpdateThingResponse
func (c *ClientWithResponses) UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThing(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

// UpdateThingConfigWithBodyWithResponse request with arbitrary body returning *UpdateThingConfigResponse
func (c *ClientWithResponses) UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfigWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfig(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

// GetThingConfigStatusWithResponse request returning *GetThingConfigStatusResponse
func (c *ClientWithResponses) GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error) {
	rsp, err := c.GetThingConfigStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingConfigStatusResponse(rsp)
}

// EnableThingWithBodyWithResponse request with arbitrary body returning *EnableThingResponse
func (c *ClientWithResponses) EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error) {
	rsp, err := c.EnableThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableThingResponse(rsp)
}

// GetThingFirmwareStatusWithResponse request returning *GetThingFirmwareStatusResponse
func (c *ClientWithResponses) GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error) {
	rsp, err := c.GetThingFirmwareStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingFirmwareStatusResponse(rsp)
}

// UpdateThingFirmwareWithResponse request returning *UpdateThingFirmwareResponse
func (c *ClientWithResponses) UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error) {
	rsp, err := c.UpdateThingFirmware(ctx, thingUID, firmwareVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingFirmwareResponse(rsp)
}

// GetAvailableFirmwaresForThingWithResponse request returning *GetAvailableFirmwaresForThingResponse
func (c *ClientWithResponses) GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error) {
	rsp, err := c.GetAvailableFirmwaresForThing(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableFirmwaresForThingResponse(rsp)
}

// GetThingStatusWithResponse request returning *GetThingStatusResponse
func (c *ClientWithResponses) GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error) {
	rsp, err := c.GetThingStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingStatusResponse(rsp)
}

// GetRegisteredUIComponentsInNamespaceWithResponse request returning *GetRegisteredUIComponentsInNamespaceResponse
func (c *ClientWithResponses) GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	rsp, err := c.GetRegisteredUIComponentsInNamespace(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegisteredUIComponentsInNamespaceResponse(rsp)
}

// AddUIComponentToNamespaceWithBodyWithResponse request with arbitrary body returning *AddUIComponentToNamespaceResponse
func (c *ClientWithResponses) AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error) {
	rsp, err := c.AddUIComponentToNamespaceWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUIComponentToNamespaceResponse(rsp)
}

// RemoveUIComponentFromNamespaceWithResponse request returning *RemoveUIComponentFromNamespaceResponse
func (c *ClientWithResponses) RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error) {
	rsp, err := c.RemoveUIComponentFromNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUIComponentFromNamespaceResponse(rsp)
}

// GetUIComponentInNamespaceWithResponse request returning *GetUIComponentInNamespaceResponse
func (c *ClientWithResponses) GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error) {
	rsp, err := c.GetUIComponentInNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUIComponentInNamespaceResponse(rsp)
}

// UpdateUIComponentInNamespaceWithBodyWithResponse request with arbitrary body returning *UpdateUIComponentInNamespaceResponse
func (c *ClientWithResponses) UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error) {
	rsp, err := c.UpdateUIComponentInNamespaceWithBody(ctx, namespace, componentUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUIComponentInNamespaceResponse(rsp)
}

// GetUITilesWithResponse request returning *GetUITilesResponse
func (c *ClientWithResponses) GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error) {
	rsp, err := c.GetUITiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUITilesResponse(rsp)
}

// GetUUIDWithResponse request returning *GetUUIDResponse
func (c *ClientWithResponses) GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error) {
	rsp, err := c.GetUUID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUUIDResponse(rsp)
}

// GetDefaultVoiceWithResponse request returning *GetDefaultVoiceResponse
func (c *ClientWithResponses) GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error) {
	rsp, err := c.GetDefaultVoice(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultVoiceResponse(rsp)
}

// GetVoiceInterpretersWithResponse request returning *GetVoiceInterpretersResponse
func (c *ClientWithResponses) GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error) {
	rsp, err := c.GetVoiceInterpreters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpretersResponse(rsp)
}

// InterpretTextByDefaultInterpreterWithBodyWithResponse request with arbitrary body returning *InterpretTextByDefaultInterpreterResponse
func (c *ClientWithResponses) InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error) {
	rsp, err := c.InterpretTextByDefaultInterpreterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextByDefaultInterpreterResponse(rsp)
}

// GetVoiceInterpreterByUIDWithResponse request returning *GetVoiceInterpreterByUIDResponse
func (c *ClientWithResponses) GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error) {
	rsp, err := c.GetVoiceInterpreterByUID(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpreterByUIDResponse(rsp)
}

// InterpretTextWithBodyWithResponse request with arbitrary body returning *InterpretTextResponse
func (c *ClientWithResponses) InterpretTextWithBodyWithResponse(ctx context.Context, id string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error) {
	rsp, err := c.InterpretTextWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextResponse(rsp)
}

// TextToSpeechWithBodyWithResponse request with arbitrary body returning *TextToSpeechResponse
func (c *ClientWithResponses) TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error) {
	rsp, err := c.TextToSpeechWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTextToSpeechResponse(rsp)
}

// GetVoicesWithResponse request returning *GetVoicesResponse
func (c *ClientWithResponses) GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error) {
	rsp, err := c.GetVoices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoicesResponse(rsp)
}

// ParseGetRootResponse parses an HTTP response from a GetRootWithResponse call
func ParseGetRootResponse(rsp *http.Response) (*GetRootResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonsResponse parses an HTTP response from a GetAddonsWithResponse call
func ParseGetAddonsResponse(rsp *http.Response) (*GetAddonsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonTypesResponse parses an HTTP response from a GetAddonTypesWithResponse call
func ParseGetAddonTypesResponse(rsp *http.Response) (*GetAddonTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddonType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallAddonFromURLResponse parses an HTTP response from a InstallAddonFromURLWithResponse call
func ParseInstallAddonFromURLResponse(rsp *http.Response) (*InstallAddonFromURLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallAddonFromURLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAddonByIdResponse parses an HTTP response from a GetAddonByIdWithResponse call
func ParseGetAddonByIdResponse(rsp *http.Response) (*GetAddonByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallAddonByIdResponse parses an HTTP response from a InstallAddonByIdWithResponse call
func ParseInstallAddonByIdResponse(rsp *http.Response) (*InstallAddonByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUninstallAddonResponse parses an HTTP response from a UninstallAddonWithResponse call
func ParseUninstallAddonResponse(rsp *http.Response) (*UninstallAddonResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAudioDefaultSinkResponse parses an HTTP response from a GetAudioDefaultSinkWithResponse call
func ParseGetAudioDefaultSinkResponse(rsp *http.Response) (*GetAudioDefaultSinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioDefaultSourceResponse parses an HTTP response from a GetAudioDefaultSourceWithResponse call
func ParseGetAudioDefaultSourceResponse(rsp *http.Response) (*GetAudioDefaultSourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSinksResponse parses an HTTP response from a GetAudioSinksWithResponse call
func ParseGetAudioSinksResponse(rsp *http.Response) (*GetAudioSinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSourcesResponse parses an HTTP response from a GetAudioSourcesWithResponse call
func ParseGetAudioSourcesResponse(rsp *http.Response) (*GetAudioSourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiTokensResponse parses an HTTP response from a GetApiTokensWithResponse call
func ParseGetApiTokensResponse(rsp *http.Response) (*GetApiTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserApiTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveApiTokenResponse parses an HTTP response from a RemoveApiTokenWithResponse call
func ParseRemoveApiTokenResponse(rsp *http.Response) (*RemoveApiTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveApiTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSessionResponse parses an HTTP response from a DeleteSessionWithResponse call
func ParseDeleteSessionResponse(rsp *http.Response) (*DeleteSessionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSessionsForCurrentUserResponse parses an HTTP response from a GetSessionsForCurrentUserWithResponse call
func ParseGetSessionsForCurrentUserResponse(rsp *http.Response) (*GetSessionsForCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionsForCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserSessionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingsResponse parses an HTTP response from a GetBindingsWithResponse call
func ParseGetBindingsResponse(rsp *http.Response) (*GetBindingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BindingInfoDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingConfigurationResponse parses an HTTP response from a GetBindingConfigurationWithResponse call
func ParseGetBindingConfigurationResponse(rsp *http.Response) (*GetBindingConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBindingConfigurationResponse parses an HTTP response from a UpdateBindingConfigurationWithResponse call
func ParseUpdateBindingConfigurationResponse(rsp *http.Response) (*UpdateBindingConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBindingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypesResponse parses an HTTP response from a GetChannelTypesWithResponse call
func ParseGetChannelTypesResponse(rsp *http.Response) (*GetChannelTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypeByUIDResponse parses an HTTP response from a GetChannelTypeByUIDWithResponse call
func ParseGetChannelTypeByUIDResponse(rsp *http.Response) (*GetChannelTypeByUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypeByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLinkableItemTypesByChannelTypeUIDResponse parses an HTTP response from a GetLinkableItemTypesByChannelTypeUIDWithResponse call
func ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp *http.Response) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkableItemTypesByChannelTypeUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionsResponse parses an HTTP response from a GetConfigDescriptionsWithResponse call
func ParseGetConfigDescriptionsResponse(rsp *http.Response) (*GetConfigDescriptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionByURIResponse parses an HTTP response from a GetConfigDescriptionByURIWithResponse call
func ParseGetConfigDescriptionByURIResponse(rsp *http.Response) (*GetConfigDescriptionByURIResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionByURIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingsWithDiscoverySupportResponse parses an HTTP response from a GetBindingsWithDiscoverySupportWithResponse call
func ParseGetBindingsWithDiscoverySupportResponse(rsp *http.Response) (*GetBindingsWithDiscoverySupportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingsWithDiscoverySupportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScanResponse parses an HTTP response from a ScanWithResponse call
func ParseScanResponse(rsp *http.Response) (*ScanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInitNewStateTackerResponse parses an HTTP response from a InitNewStateTackerWithResponse call
func ParseInitNewStateTackerResponse(rsp *http.Response) (*InitNewStateTackerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitNewStateTackerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemListForStateUpdatesResponse parses an HTTP response from a UpdateItemListForStateUpdatesWithResponse call
func ParseUpdateItemListForStateUpdatesResponse(rsp *http.Response) (*UpdateItemListForStateUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemListForStateUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetIconSetsResponse parses an HTTP response from a GetIconSetsWithResponse call
func ParseGetIconSetsResponse(rsp *http.Response) (*GetIconSetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIconSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IconSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDiscoveredInboxItemsResponse parses an HTTP response from a GetDiscoveredInboxItemsWithResponse call
func ParseGetDiscoveredInboxItemsResponse(rsp *http.Response) (*GetDiscoveredInboxItemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscoveredInboxItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiscoveryResultDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveItemFromInboxResponse parses an HTTP response from a RemoveItemFromInboxWithResponse call
func ParseRemoveItemFromInboxResponse(rsp *http.Response) (*RemoveItemFromInboxResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromInboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseApproveInboxItemByIdResponse parses an HTTP response from a ApproveInboxItemByIdWithResponse call
func ParseApproveInboxItemByIdResponse(rsp *http.Response) (*ApproveInboxItemByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveInboxItemByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFlagInboxItemAsIgnoredResponse parses an HTTP response from a FlagInboxItemAsIgnoredWithResponse call
func ParseFlagInboxItemAsIgnoredResponse(rsp *http.Response) (*FlagInboxItemAsIgnoredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FlagInboxItemAsIgnoredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveIgnoreFlagOnInboxItemResponse parses an HTTP response from a RemoveIgnoreFlagOnInboxItemWithResponse call
func ParseRemoveIgnoreFlagOnInboxItemResponse(rsp *http.Response) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveIgnoreFlagOnInboxItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemsResponse parses an HTTP response from a GetItemsWithResponse call
func ParseGetItemsResponse(rsp *http.Response) (*GetItemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrUpdateItemsInRegistryResponse parses an HTTP response from a AddOrUpdateItemsInRegistryWithResponse call
func ParseAddOrUpdateItemsInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemsInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemsInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMemberFromGroupItemResponse parses an HTTP response from a RemoveMemberFromGroupItemWithResponse call
func ParseRemoveMemberFromGroupItemResponse(rsp *http.Response) (*RemoveMemberFromGroupItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMemberFromGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMemberToGroupItemResponse parses an HTTP response from a AddMemberToGroupItemWithResponse call
func ParseAddMemberToGroupItemResponse(rsp *http.Response) (*AddMemberToGroupItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMemberToGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveItemFromRegistryResponse parses an HTTP response from a RemoveItemFromRegistryWithResponse call
func ParseRemoveItemFromRegistryResponse(rsp *http.Response) (*RemoveItemFromRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemByNameResponse parses an HTTP response from a GetItemByNameWithResponse call
func ParseGetItemByNameResponse(rsp *http.Response) (*GetItemByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendItemCommandResponse parses an HTTP response from a SendItemCommandWithResponse call
func ParseSendItemCommandResponse(rsp *http.Response) (*SendItemCommandResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendItemCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOrUpdateItemInRegistryResponse parses an HTTP response from a AddOrUpdateItemInRegistryWithResponse call
func ParseAddOrUpdateItemInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMetadataFromItemResponse parses an HTTP response from a RemoveMetadataFromItemWithResponse call
func ParseRemoveMetadataFromItemResponse(rsp *http.Response) (*RemoveMetadataFromItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMetadataFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMetadataToItemResponse parses an HTTP response from a AddMetadataToItemWithResponse call
func ParseAddMetadataToItemResponse(rsp *http.Response) (*AddMetadataToItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMetadataToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemStateResponse parses an HTTP response from a GetItemStateWithResponse call
func ParseGetItemStateResponse(rsp *http.Response) (*GetItemStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemStateResponse parses an HTTP response from a UpdateItemStateWithResponse call
func ParseUpdateItemStateResponse(rsp *http.Response) (*UpdateItemStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveTagFromItemResponse parses an HTTP response from a RemoveTagFromItemWithResponse call
func ParseRemoveTagFromItemResponse(rsp *http.Response) (*RemoveTagFromItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddTagToItemResponse parses an HTTP response from a AddTagToItemWithResponse call
func ParseAddTagToItemResponse(rsp *http.Response) (*AddTagToItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTagToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinksResponse parses an HTTP response from a GetItemLinksWithResponse call
func ParseGetItemLinksResponse(rsp *http.Response) (*GetItemLinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemChannelLinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkItemFromChannelResponse parses an HTTP response from a UnlinkItemFromChannelWithResponse call
func ParseUnlinkItemFromChannelResponse(rsp *http.Response) (*UnlinkItemFromChannelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkItemFromChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinkResponse parses an HTTP response from a GetItemLinkWithResponse call
func ParseGetItemLinkResponse(rsp *http.Response) (*GetItemLinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLinkItemToChannelResponse parses an HTTP response from a LinkItemToChannelWithResponse call
func ParseLinkItemToChannelResponse(rsp *http.Response) (*LinkItemToChannelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkItemToChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModuleTypesResponse parses an HTTP response from a GetModuleTypesWithResponse call
func ParseGetModuleTypesResponse(rsp *http.Response) (*GetModuleTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModuleTypeByIdResponse parses an HTTP response from a GetModuleTypeByIdWithResponse call
func ParseGetModuleTypeByIdResponse(rsp *http.Response) (*GetModuleTypeByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersistenceServicesResponse parses an HTTP response from a GetPersistenceServicesWithResponse call
func ParseGetPersistenceServicesResponse(rsp *http.Response) (*GetPersistenceServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemsForPersistenceServiceResponse parses an HTTP response from a GetItemsForPersistenceServiceWithResponse call
func ParseGetItemsForPersistenceServiceResponse(rsp *http.Response) (*GetItemsForPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsForPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceItemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteItemFromPersistenceServiceResponse parses an HTTP response from a DeleteItemFromPersistenceServiceWithResponse call
func ParseDeleteItemFromPersistenceServiceResponse(rsp *http.Response) (*DeleteItemFromPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemDataFromPersistenceServiceResponse parses an HTTP response from a GetItemDataFromPersistenceServiceWithResponse call
func ParseGetItemDataFromPersistenceServiceResponse(rsp *http.Response) (*GetItemDataFromPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemDataFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemHistoryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreItemDataInPersistenceServiceResponse parses an HTTP response from a StoreItemDataInPersistenceServiceWithResponse call
func ParseStoreItemDataInPersistenceServiceResponse(rsp *http.Response) (*StoreItemDataInPersistenceServiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreItemDataInPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProfileTypesResponse parses an HTTP response from a GetProfileTypesWithResponse call
func ParseGetProfileTypesResponse(rsp *http.Response) (*GetProfileTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProfileTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScheduleRuleSimulationsResponse parses an HTTP response from a GetScheduleRuleSimulationsWithResponse call
func ParseGetScheduleRuleSimulationsResponse(rsp *http.Response) (*GetScheduleRuleSimulationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleRuleSimulationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RuleExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleByIdResponse parses an HTTP response from a GetRuleByIdWithResponse call
func ParseGetRuleByIdResponse(rsp *http.Response) (*GetRuleByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleActionsResponse parses an HTTP response from a GetRuleActionsWithResponse call
func ParseGetRuleActionsResponse(rsp *http.Response) (*GetRuleActionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConditionsResponse parses an HTTP response from a GetRuleConditionsWithResponse call
func ParseGetRuleConditionsResponse(rsp *http.Response) (*GetRuleConditionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConditionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConfigurationResponse parses an HTTP response from a GetRuleConfigurationWithResponse call
func ParseGetRuleConfigurationResponse(rsp *http.Response) (*GetRuleConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleConfigurationResponse parses an HTTP response from a UpdateRuleConfigurationWithResponse call
func ParseUpdateRuleConfigurationResponse(rsp *http.Response) (*UpdateRuleConfigurationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnableRuleResponse parses an HTTP response from a EnableRuleWithResponse call
func ParseEnableRuleResponse(rsp *http.Response) (*EnableRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunRuleNowResponse parses an HTTP response from a RunRuleNowWithResponse call
func ParseRunRuleNowResponse(rsp *http.Response) (*RunRuleNowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunRuleNowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleTriggersResponse parses an HTTP response from a GetRuleTriggersWithResponse call
func ParseGetRuleTriggersResponse(rsp *http.Response) (*GetRuleTriggersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TriggerDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleByIdResponse parses an HTTP response from a GetRuleModuleByIdWithResponse call
func ParseGetRuleModuleByIdResponse(rsp *http.Response) (*GetRuleModuleByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigResponse parses an HTTP response from a GetRuleModuleConfigWithResponse call
func ParseGetRuleModuleConfigResponse(rsp *http.Response) (*GetRuleModuleConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigParameterResponse parses an HTTP response from a GetRuleModuleConfigParameterWithResponse call
func ParseGetRuleModuleConfigParameterResponse(rsp *http.Response) (*GetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRuleModuleConfigParameterResponse parses an HTTP response from a SetRuleModuleConfigParameterWithResponse call
func ParseSetRuleModuleConfigParameterResponse(rsp *http.Response) (*SetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesByIdResponse parses an HTTP response from a GetServicesByIdWithResponse call
func ParseGetServicesByIdResponse(rsp *http.Response) (*GetServicesByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceConfigResponse parses an HTTP response from a DeleteServiceConfigWithResponse call
func ParseDeleteServiceConfigResponse(rsp *http.Response) (*DeleteServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceConfigResponse parses an HTTP response from a GetServiceConfigWithResponse call
func ParseGetServiceConfigResponse(rsp *http.Response) (*GetServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceConfigResponse parses an HTTP response from a UpdateServiceConfigWithResponse call
func ParseUpdateServiceConfigResponse(rsp *http.Response) (*UpdateServiceConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceContextResponse parses an HTTP response from a GetServiceContextWithResponse call
func ParseGetServiceContextResponse(rsp *http.Response) (*GetServiceContextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSitemapsResponse parses an HTTP response from a GetSitemapsWithResponse call
func ParseGetSitemapsResponse(rsp *http.Response) (*GetSitemapsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSitemapEventSubscriptionResponse parses an HTTP response from a CreateSitemapEventSubscriptionWithResponse call
func ParseCreateSitemapEventSubscriptionResponse(rsp *http.Response) (*CreateSitemapEventSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSitemapEventSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapEventsResponse parses an HTTP response from a GetSitemapEventsWithResponse call
func ParseGetSitemapEventsResponse(rsp *http.Response) (*GetSitemapEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapByNameResponse parses an HTTP response from a GetSitemapByNameWithResponse call
func ParseGetSitemapByNameResponse(rsp *http.Response) (*GetSitemapByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePollDataForSitemapResponse parses an HTTP response from a PollDataForSitemapWithResponse call
func ParsePollDataForSitemapResponse(rsp *http.Response) (*PollDataForSitemapResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollDataForSitemapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSystemInformationResponse parses an HTTP response from a GetSystemInformationWithResponse call
func ParseGetSystemInformationResponse(rsp *http.Response) (*GetSystemInformationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfoBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplatesResponse parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResponse(rsp *http.Response) (*GetTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateByIdResponse parses an HTTP response from a GetTemplateByIdWithResponse call
func ParseGetTemplateByIdResponse(rsp *http.Response) (*GetTemplateByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypesResponse parses an HTTP response from a GetThingTypesWithResponse call
func ParseGetThingTypesResponse(rsp *http.Response) (*GetThingTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StrippedThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypeByIdResponse parses an HTTP response from a GetThingTypeByIdWithResponse call
func ParseGetThingTypeByIdResponse(rsp *http.Response) (*GetThingTypeByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingsResponse parses an HTTP response from a GetThingsWithResponse call
func ParseGetThingsResponse(rsp *http.Response) (*GetThingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateThingInRegistryResponse parses an HTTP response from a CreateThingInRegistryWithResponse call
func ParseCreateThingInRegistryResponse(rsp *http.Response) (*CreateThingInRegistryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateThingInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveThingByIdResponse parses an HTTP response from a RemoveThingByIdWithResponse call
func ParseRemoveThingByIdResponse(rsp *http.Response) (*RemoveThingByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingByIdResponse parses an HTTP response from a GetThingByIdWithResponse call
func ParseGetThingByIdResponse(rsp *http.Response) (*GetThingByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateThingResponse parses an HTTP response from a UpdateThingWithResponse call
func ParseUpdateThingResponse(rsp *http.Response) (*UpdateThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingConfigResponse parses an HTTP response from a UpdateThingConfigWithResponse call
func ParseUpdateThingConfigResponse(rsp *http.Response) (*UpdateThingConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingConfigStatusResponse parses an HTTP response from a GetThingConfigStatusWithResponse call
func ParseGetThingConfigStatusResponse(rsp *http.Response) (*GetThingConfigStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingConfigStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigStatusMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnableThingResponse parses an HTTP response from a EnableThingWithResponse call
func ParseEnableThingResponse(rsp *http.Response) (*EnableThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingFirmwareStatusResponse parses an HTTP response from a GetThingFirmwareStatusWithResponse call
func ParseGetThingFirmwareStatusResponse(rsp *http.Response) (*GetThingFirmwareStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingFirmwareStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingFirmwareResponse parses an HTTP response from a UpdateThingFirmwareWithResponse call
func ParseUpdateThingFirmwareResponse(rsp *http.Response) (*UpdateThingFirmwareResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingFirmwareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAvailableFirmwaresForThingResponse parses an HTTP response from a GetAvailableFirmwaresForThingWithResponse call
func ParseGetAvailableFirmwaresForThingResponse(rsp *http.Response) (*GetAvailableFirmwaresForThingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableFirmwaresForThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FirmwareDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingStatusResponse parses an HTTP response from a GetThingStatusWithResponse call
func ParseGetThingStatusResponse(rsp *http.Response) (*GetThingStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingStatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegisteredUIComponentsInNamespaceResponse parses an HTTP response from a GetRegisteredUIComponentsInNamespaceWithResponse call
func ParseGetRegisteredUIComponentsInNamespaceResponse(rsp *http.Response) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegisteredUIComponentsInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUIComponentToNamespaceResponse parses an HTTP response from a AddUIComponentToNamespaceWithResponse call
func ParseAddUIComponentToNamespaceResponse(rsp *http.Response) (*AddUIComponentToNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUIComponentToNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUIComponentFromNamespaceResponse parses an HTTP response from a RemoveUIComponentFromNamespaceWithResponse call
func ParseRemoveUIComponentFromNamespaceResponse(rsp *http.Response) (*RemoveUIComponentFromNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUIComponentFromNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUIComponentInNamespaceResponse parses an HTTP response from a GetUIComponentInNamespaceWithResponse call
func ParseGetUIComponentInNamespaceResponse(rsp *http.Response) (*GetUIComponentInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUIComponentInNamespaceResponse parses an HTTP response from a UpdateUIComponentInNamespaceWithResponse call
func ParseUpdateUIComponentInNamespaceResponse(rsp *http.Response) (*UpdateUIComponentInNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUITilesResponse parses an HTTP response from a GetUITilesWithResponse call
func ParseGetUITilesResponse(rsp *http.Response) (*GetUITilesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUITilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TileDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUUIDResponse parses an HTTP response from a GetUUIDWithResponse call
func ParseGetUUIDResponse(rsp *http.Response) (*GetUUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultVoiceResponse parses an HTTP response from a GetDefaultVoiceWithResponse call
func ParseGetDefaultVoiceResponse(rsp *http.Response) (*GetDefaultVoiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultVoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVoiceInterpretersResponse parses an HTTP response from a GetVoiceInterpretersWithResponse call
func ParseGetVoiceInterpretersResponse(rsp *http.Response) (*GetVoiceInterpretersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpretersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInterpretTextByDefaultInterpreterResponse parses an HTTP response from a InterpretTextByDefaultInterpreterWithResponse call
func ParseInterpretTextByDefaultInterpreterResponse(rsp *http.Response) (*InterpretTextByDefaultInterpreterResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextByDefaultInterpreterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoiceInterpreterByUIDResponse parses an HTTP response from a GetVoiceInterpreterByUIDWithResponse call
func ParseGetVoiceInterpreterByUIDResponse(rsp *http.Response) (*GetVoiceInterpreterByUIDResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpreterByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInterpretTextResponse parses an HTTP response from a InterpretTextWithResponse call
func ParseInterpretTextResponse(rsp *http.Response) (*InterpretTextResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTextToSpeechResponse parses an HTTP response from a TextToSpeechWithResponse call
func ParseTextToSpeechResponse(rsp *http.Response) (*TextToSpeechResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TextToSpeechResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoicesResponse parses an HTTP response from a GetVoicesWithResponse call
func ParseGetVoicesResponse(rsp *http.Response) (*GetVoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
