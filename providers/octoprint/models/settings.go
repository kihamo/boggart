// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// Settings settings
//
// swagger:model Settings
type Settings struct {

	// api
	API *SettingsAPI `json:"api,omitempty"`

	// appearance
	Appearance *SettingsAppearance `json:"appearance,omitempty"`

	// feature
	Feature *SettingsFeature `json:"feature,omitempty"`

	// folder
	Folder *SettingsFolder `json:"folder,omitempty"`

	// plugins
	Plugins *SettingsPlugins `json:"plugins,omitempty"`

	// printer
	Printer *SettingsPrinter `json:"printer,omitempty"`

	// scripts
	Scripts *SettingsScripts `json:"scripts,omitempty"`

	// serial
	Serial *SettingsSerial `json:"serial,omitempty"`

	// webcam
	Webcam *SettingsWebcam `json:"webcam,omitempty"`

	// settings
	Settings map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *Settings) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// api
		API *SettingsAPI `json:"api,omitempty"`

		// appearance
		Appearance *SettingsAppearance `json:"appearance,omitempty"`

		// feature
		Feature *SettingsFeature `json:"feature,omitempty"`

		// folder
		Folder *SettingsFolder `json:"folder,omitempty"`

		// plugins
		Plugins *SettingsPlugins `json:"plugins,omitempty"`

		// printer
		Printer *SettingsPrinter `json:"printer,omitempty"`

		// scripts
		Scripts *SettingsScripts `json:"scripts,omitempty"`

		// serial
		Serial *SettingsSerial `json:"serial,omitempty"`

		// webcam
		Webcam *SettingsWebcam `json:"webcam,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv Settings

	rcv.API = stage1.API
	rcv.Appearance = stage1.Appearance
	rcv.Feature = stage1.Feature
	rcv.Folder = stage1.Folder
	rcv.Plugins = stage1.Plugins
	rcv.Printer = stage1.Printer
	rcv.Scripts = stage1.Scripts
	rcv.Serial = stage1.Serial
	rcv.Webcam = stage1.Webcam
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "api")
	delete(stage2, "appearance")
	delete(stage2, "feature")
	delete(stage2, "folder")
	delete(stage2, "plugins")
	delete(stage2, "printer")
	delete(stage2, "scripts")
	delete(stage2, "serial")
	delete(stage2, "webcam")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.Settings = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m Settings) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// api
		API *SettingsAPI `json:"api,omitempty"`

		// appearance
		Appearance *SettingsAppearance `json:"appearance,omitempty"`

		// feature
		Feature *SettingsFeature `json:"feature,omitempty"`

		// folder
		Folder *SettingsFolder `json:"folder,omitempty"`

		// plugins
		Plugins *SettingsPlugins `json:"plugins,omitempty"`

		// printer
		Printer *SettingsPrinter `json:"printer,omitempty"`

		// scripts
		Scripts *SettingsScripts `json:"scripts,omitempty"`

		// serial
		Serial *SettingsSerial `json:"serial,omitempty"`

		// webcam
		Webcam *SettingsWebcam `json:"webcam,omitempty"`
	}

	stage1.API = m.API
	stage1.Appearance = m.Appearance
	stage1.Feature = m.Feature
	stage1.Folder = m.Folder
	stage1.Plugins = m.Plugins
	stage1.Printer = m.Printer
	stage1.Scripts = m.Scripts
	stage1.Serial = m.Serial
	stage1.Webcam = m.Webcam

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.Settings) == 0 { // no additional properties
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.Settings)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 { // "{}": only additional properties
		return additional, nil
	}

	// concatenate the 2 objects
	return swag.ConcatJSON(props, additional), nil
}

// Validate validates this settings
func (m *Settings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAPI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppearance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFolder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlugins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrinter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSerial(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWebcam(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Settings) validateAPI(formats strfmt.Registry) error {
	if swag.IsZero(m.API) { // not required
		return nil
	}

	if m.API != nil {
		if err := m.API.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("api")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("api")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateAppearance(formats strfmt.Registry) error {
	if swag.IsZero(m.Appearance) { // not required
		return nil
	}

	if m.Appearance != nil {
		if err := m.Appearance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appearance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appearance")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateFeature(formats strfmt.Registry) error {
	if swag.IsZero(m.Feature) { // not required
		return nil
	}

	if m.Feature != nil {
		if err := m.Feature.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateFolder(formats strfmt.Registry) error {
	if swag.IsZero(m.Folder) { // not required
		return nil
	}

	if m.Folder != nil {
		if err := m.Folder.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("folder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("folder")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validatePlugins(formats strfmt.Registry) error {
	if swag.IsZero(m.Plugins) { // not required
		return nil
	}

	if m.Plugins != nil {
		if err := m.Plugins.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validatePrinter(formats strfmt.Registry) error {
	if swag.IsZero(m.Printer) { // not required
		return nil
	}

	if m.Printer != nil {
		if err := m.Printer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("printer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("printer")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateScripts(formats strfmt.Registry) error {
	if swag.IsZero(m.Scripts) { // not required
		return nil
	}

	if m.Scripts != nil {
		if err := m.Scripts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scripts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scripts")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateSerial(formats strfmt.Registry) error {
	if swag.IsZero(m.Serial) { // not required
		return nil
	}

	if m.Serial != nil {
		if err := m.Serial.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("serial")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("serial")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) validateWebcam(formats strfmt.Registry) error {
	if swag.IsZero(m.Webcam) { // not required
		return nil
	}

	if m.Webcam != nil {
		if err := m.Webcam.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("webcam")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("webcam")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this settings based on the context it is used
func (m *Settings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAPI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppearance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeature(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFolder(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlugins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrinter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScripts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSerial(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWebcam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Settings) contextValidateAPI(ctx context.Context, formats strfmt.Registry) error {

	if m.API != nil {
		if err := m.API.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("api")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("api")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateAppearance(ctx context.Context, formats strfmt.Registry) error {

	if m.Appearance != nil {
		if err := m.Appearance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appearance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appearance")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateFeature(ctx context.Context, formats strfmt.Registry) error {

	if m.Feature != nil {
		if err := m.Feature.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("feature")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("feature")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateFolder(ctx context.Context, formats strfmt.Registry) error {

	if m.Folder != nil {
		if err := m.Folder.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("folder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("folder")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidatePlugins(ctx context.Context, formats strfmt.Registry) error {

	if m.Plugins != nil {
		if err := m.Plugins.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidatePrinter(ctx context.Context, formats strfmt.Registry) error {

	if m.Printer != nil {
		if err := m.Printer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("printer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("printer")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateScripts(ctx context.Context, formats strfmt.Registry) error {

	if m.Scripts != nil {
		if err := m.Scripts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scripts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scripts")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateSerial(ctx context.Context, formats strfmt.Registry) error {

	if m.Serial != nil {
		if err := m.Serial.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("serial")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("serial")
			}
			return err
		}
	}

	return nil
}

func (m *Settings) contextValidateWebcam(ctx context.Context, formats strfmt.Registry) error {

	if m.Webcam != nil {
		if err := m.Webcam.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("webcam")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("webcam")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Settings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Settings) UnmarshalBinary(b []byte) error {
	var res Settings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsAPI settings API
//
// swagger:model SettingsAPI
type SettingsAPI struct {

	// allow cross origin
	AllowCrossOrigin bool `json:"allowCrossOrigin,omitempty"`

	// key
	Key string `json:"key,omitempty"`
}

// Validate validates this settings API
func (m *SettingsAPI) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings API based on context it is used
func (m *SettingsAPI) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsAPI) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsAPI) UnmarshalBinary(b []byte) error {
	var res SettingsAPI
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsAppearance settings appearance
//
// swagger:model SettingsAppearance
type SettingsAppearance struct {

	// color
	Color string `json:"color,omitempty"`

	// color icon
	ColorIcon bool `json:"colorIcon,omitempty"`

	// color transparent
	ColorTransparent bool `json:"colorTransparent,omitempty"`

	// default language
	DefaultLanguage string `json:"defaultLanguage,omitempty"`

	// fuzzy times
	FuzzyTimes bool `json:"fuzzyTimes,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// show fahrenheit also
	ShowFahrenheitAlso bool `json:"showFahrenheitAlso,omitempty"`
}

// Validate validates this settings appearance
func (m *SettingsAppearance) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings appearance based on context it is used
func (m *SettingsAppearance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsAppearance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsAppearance) UnmarshalBinary(b []byte) error {
	var res SettingsAppearance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsFeature settings feature
//
// swagger:model SettingsFeature
type SettingsFeature struct {

	// auto uppercase blacklist
	AutoUppercaseBlacklist []string `json:"autoUppercaseBlacklist"`

	// g90 influences extruder
	G90InfluencesExtruder bool `json:"g90InfluencesExtruder,omitempty"`

	// gcode viewer
	GcodeViewer bool `json:"gcodeViewer,omitempty"`

	// keyboard control
	KeyboardControl bool `json:"keyboardControl,omitempty"`

	// mobile size threshold
	MobileSizeThreshold int64 `json:"mobileSizeThreshold,omitempty"`

	// model size detection
	ModelSizeDetection bool `json:"modelSizeDetection,omitempty"`

	// poll watched
	PollWatched bool `json:"pollWatched,omitempty"`

	// print cancel confirmation
	PrintCancelConfirmation bool `json:"printCancelConfirmation,omitempty"`

	// sd support
	SdSupport bool `json:"sdSupport,omitempty"`

	// size threshold
	SizeThreshold int64 `json:"sizeThreshold,omitempty"`

	// temperature graph
	TemperatureGraph bool `json:"temperatureGraph,omitempty"`
}

// Validate validates this settings feature
func (m *SettingsFeature) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings feature based on context it is used
func (m *SettingsFeature) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsFeature) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsFeature) UnmarshalBinary(b []byte) error {
	var res SettingsFeature
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsFolder settings folder
//
// swagger:model SettingsFolder
type SettingsFolder struct {

	// logs
	Logs string `json:"logs,omitempty"`

	// timelapse
	Timelapse string `json:"timelapse,omitempty"`

	// timelapse tmp
	TimelapseTmp string `json:"timelapseTmp,omitempty"`

	// uploads
	Uploads string `json:"uploads,omitempty"`

	// watched
	Watched string `json:"watched,omitempty"`
}

// Validate validates this settings folder
func (m *SettingsFolder) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings folder based on context it is used
func (m *SettingsFolder) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsFolder) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsFolder) UnmarshalBinary(b []byte) error {
	var res SettingsFolder
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPlugins settings plugins
//
// swagger:model SettingsPlugins
type SettingsPlugins struct {

	// mqtt
	Mqtt *SettingsPluginsMqtt `json:"mqtt,omitempty"`

	// settings plugins
	SettingsPlugins map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *SettingsPlugins) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// mqtt
		Mqtt *SettingsPluginsMqtt `json:"mqtt,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv SettingsPlugins

	rcv.Mqtt = stage1.Mqtt
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "mqtt")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.SettingsPlugins = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m SettingsPlugins) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// mqtt
		Mqtt *SettingsPluginsMqtt `json:"mqtt,omitempty"`
	}

	stage1.Mqtt = m.Mqtt

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.SettingsPlugins) == 0 { // no additional properties
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.SettingsPlugins)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 { // "{}": only additional properties
		return additional, nil
	}

	// concatenate the 2 objects
	return swag.ConcatJSON(props, additional), nil
}

// Validate validates this settings plugins
func (m *SettingsPlugins) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMqtt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPlugins) validateMqtt(formats strfmt.Registry) error {
	if swag.IsZero(m.Mqtt) { // not required
		return nil
	}

	if m.Mqtt != nil {
		if err := m.Mqtt.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this settings plugins based on the context it is used
func (m *SettingsPlugins) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMqtt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPlugins) contextValidateMqtt(ctx context.Context, formats strfmt.Registry) error {

	if m.Mqtt != nil {
		if err := m.Mqtt.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPlugins) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPlugins) UnmarshalBinary(b []byte) error {
	var res SettingsPlugins
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPluginsMqtt settings plugins mqtt
//
// swagger:model SettingsPluginsMqtt
type SettingsPluginsMqtt struct {

	// broker
	Broker *SettingsPluginsMqttBroker `json:"broker,omitempty"`

	// client
	Client *SettingsPluginsMqttClient `json:"client,omitempty"`

	// publish
	Publish *SettingsPluginsMqttPublish `json:"publish,omitempty"`

	// timestamp fieldname
	TimestampFieldname string `json:"timestamp_fieldname,omitempty"`
}

// Validate validates this settings plugins mqtt
func (m *SettingsPluginsMqtt) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBroker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClient(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublish(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPluginsMqtt) validateBroker(formats strfmt.Registry) error {
	if swag.IsZero(m.Broker) { // not required
		return nil
	}

	if m.Broker != nil {
		if err := m.Broker.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "broker")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "broker")
			}
			return err
		}
	}

	return nil
}

func (m *SettingsPluginsMqtt) validateClient(formats strfmt.Registry) error {
	if swag.IsZero(m.Client) { // not required
		return nil
	}

	if m.Client != nil {
		if err := m.Client.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "client")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "client")
			}
			return err
		}
	}

	return nil
}

func (m *SettingsPluginsMqtt) validatePublish(formats strfmt.Registry) error {
	if swag.IsZero(m.Publish) { // not required
		return nil
	}

	if m.Publish != nil {
		if err := m.Publish.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "publish")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "publish")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this settings plugins mqtt based on the context it is used
func (m *SettingsPluginsMqtt) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBroker(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClient(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePublish(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPluginsMqtt) contextValidateBroker(ctx context.Context, formats strfmt.Registry) error {

	if m.Broker != nil {
		if err := m.Broker.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "broker")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "broker")
			}
			return err
		}
	}

	return nil
}

func (m *SettingsPluginsMqtt) contextValidateClient(ctx context.Context, formats strfmt.Registry) error {

	if m.Client != nil {
		if err := m.Client.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "client")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "client")
			}
			return err
		}
	}

	return nil
}

func (m *SettingsPluginsMqtt) contextValidatePublish(ctx context.Context, formats strfmt.Registry) error {

	if m.Publish != nil {
		if err := m.Publish.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "publish")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "publish")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPluginsMqtt) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPluginsMqtt) UnmarshalBinary(b []byte) error {
	var res SettingsPluginsMqtt
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPluginsMqttBroker settings plugins mqtt broker
//
// swagger:model SettingsPluginsMqttBroker
type SettingsPluginsMqttBroker struct {

	// clean session
	CleanSession bool `json:"clean_session,omitempty"`

	// keepalive
	Keepalive int64 `json:"keepalive,omitempty"`

	// password
	Password string `json:"password,omitempty"`

	// port
	Port int64 `json:"port,omitempty"`

	// protocol
	Protocol string `json:"protocol,omitempty"`

	// retain
	Retain bool `json:"retain,omitempty"`

	// tls
	TLS interface{} `json:"tls,omitempty"`

	// tls active
	TLSActive bool `json:"tls_active,omitempty"`

	// tls insecure
	TLSInsecure bool `json:"tls_insecure,omitempty"`

	// url
	URL string `json:"url,omitempty"`

	// username
	Username string `json:"username,omitempty"`
}

// Validate validates this settings plugins mqtt broker
func (m *SettingsPluginsMqttBroker) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings plugins mqtt broker based on context it is used
func (m *SettingsPluginsMqttBroker) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPluginsMqttBroker) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPluginsMqttBroker) UnmarshalBinary(b []byte) error {
	var res SettingsPluginsMqttBroker
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPluginsMqttClient settings plugins mqtt client
//
// swagger:model SettingsPluginsMqttClient
type SettingsPluginsMqttClient struct {

	// client id
	ClientID string `json:"client_id,omitempty"`
}

// Validate validates this settings plugins mqtt client
func (m *SettingsPluginsMqttClient) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings plugins mqtt client based on context it is used
func (m *SettingsPluginsMqttClient) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPluginsMqttClient) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPluginsMqttClient) UnmarshalBinary(b []byte) error {
	var res SettingsPluginsMqttClient
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPluginsMqttPublish settings plugins mqtt publish
//
// swagger:model SettingsPluginsMqttPublish
type SettingsPluginsMqttPublish struct {

	// base topic
	BaseTopic string `json:"baseTopic,omitempty"`

	// event active
	EventActive bool `json:"eventActive,omitempty"`

	// event topic
	EventTopic string `json:"eventTopic,omitempty"`

	// events
	Events *SettingsPluginsMqttPublishEvents `json:"events,omitempty"`

	// lw active
	LwActive bool `json:"lwActive,omitempty"`

	// lw topic
	LwTopic string `json:"lwTopic,omitempty"`

	// printer data
	PrinterData bool `json:"printerData,omitempty"`

	// progress active
	ProgressActive bool `json:"progressActive,omitempty"`

	// progress topic
	ProgressTopic string `json:"progressTopic,omitempty"`

	// temperature active
	TemperatureActive bool `json:"temperatureActive,omitempty"`

	// temperature threshold
	TemperatureThreshold float64 `json:"temperatureThreshold,omitempty"`

	// temperature topic
	TemperatureTopic string `json:"temperatureTopic,omitempty"`
}

// Validate validates this settings plugins mqtt publish
func (m *SettingsPluginsMqttPublish) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPluginsMqttPublish) validateEvents(formats strfmt.Registry) error {
	if swag.IsZero(m.Events) { // not required
		return nil
	}

	if m.Events != nil {
		if err := m.Events.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "publish" + "." + "events")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "publish" + "." + "events")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this settings plugins mqtt publish based on the context it is used
func (m *SettingsPluginsMqttPublish) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SettingsPluginsMqttPublish) contextValidateEvents(ctx context.Context, formats strfmt.Registry) error {

	if m.Events != nil {
		if err := m.Events.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugins" + "." + "mqtt" + "." + "publish" + "." + "events")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugins" + "." + "mqtt" + "." + "publish" + "." + "events")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPluginsMqttPublish) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPluginsMqttPublish) UnmarshalBinary(b []byte) error {
	var res SettingsPluginsMqttPublish
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPluginsMqttPublishEvents settings plugins mqtt publish events
//
// swagger:model SettingsPluginsMqttPublishEvents
type SettingsPluginsMqttPublishEvents struct {

	// comm
	Comm bool `json:"comm,omitempty"`

	// files
	Files bool `json:"files,omitempty"`

	// gcode
	Gcode bool `json:"gcode,omitempty"`

	// printjob
	Printjob bool `json:"printjob,omitempty"`

	// server
	Server bool `json:"server,omitempty"`

	// settings
	Settings bool `json:"settings,omitempty"`

	// slicing
	Slicing bool `json:"slicing,omitempty"`

	// timelapse
	Timelapse bool `json:"timelapse,omitempty"`

	// unclassified
	Unclassified bool `json:"unclassified,omitempty"`
}

// Validate validates this settings plugins mqtt publish events
func (m *SettingsPluginsMqttPublishEvents) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings plugins mqtt publish events based on context it is used
func (m *SettingsPluginsMqttPublishEvents) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPluginsMqttPublishEvents) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPluginsMqttPublishEvents) UnmarshalBinary(b []byte) error {
	var res SettingsPluginsMqttPublishEvents
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsPrinter settings printer
//
// swagger:model SettingsPrinter
type SettingsPrinter struct {

	// default extrusion length
	DefaultExtrusionLength int64 `json:"defaultExtrusionLength,omitempty"`
}

// Validate validates this settings printer
func (m *SettingsPrinter) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings printer based on context it is used
func (m *SettingsPrinter) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsPrinter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsPrinter) UnmarshalBinary(b []byte) error {
	var res SettingsPrinter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsScripts settings scripts
//
// swagger:model SettingsScripts
type SettingsScripts struct {

	// gcode
	Gcode map[string]interface{} `json:"gcode,omitempty"`
}

// Validate validates this settings scripts
func (m *SettingsScripts) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings scripts based on context it is used
func (m *SettingsScripts) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsScripts) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsScripts) UnmarshalBinary(b []byte) error {
	var res SettingsScripts
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsSerial settings serial
//
// swagger:model SettingsSerial
type SettingsSerial struct {

	// abort heatup on cancel
	AbortHeatupOnCancel bool `json:"abortHeatupOnCancel,omitempty"`

	// additional baudrates
	AdditionalBaudrates []int64 `json:"additionalBaudrates"`

	// additional ports
	AdditionalPorts []string `json:"additionalPorts"`

	// always send checksum
	AlwaysSendChecksum bool `json:"alwaysSendChecksum,omitempty"`

	// autoconnect
	Autoconnect bool `json:"autoconnect,omitempty"`

	// baudrate
	Baudrate int64 `json:"baudrate,omitempty"`

	// baudrate options
	BaudrateOptions []int64 `json:"baudrateOptions"`

	// block while dwelling
	BlockWhileDwelling bool `json:"blockWhileDwelling,omitempty"`

	// blocked commands
	BlockedCommands []string `json:"blockedCommands"`

	// cap autoreport sd status
	CapAutoreportSdStatus bool `json:"capAutoreportSdStatus,omitempty"`

	// cap autoreport temp
	CapAutoreportTemp bool `json:"capAutoreportTemp,omitempty"`

	// cap busy protocol
	CapBusyProtocol bool `json:"capBusyProtocol,omitempty"`

	// cap emergency parser
	CapEmergencyParser bool `json:"capEmergencyParser,omitempty"`

	// checksum requiring commands
	ChecksumRequiringCommands []string `json:"checksumRequiringCommands"`

	// disconnect on errors
	DisconnectOnErrors bool `json:"disconnectOnErrors,omitempty"`

	// exclusive
	Exclusive bool `json:"exclusive,omitempty"`

	// external heatup detection
	ExternalHeatupDetection bool `json:"externalHeatupDetection,omitempty"`

	// firmware detection
	FirmwareDetection bool `json:"firmwareDetection,omitempty"`

	// hello command
	HelloCommand string `json:"helloCommand,omitempty"`

	// ignore errors from firmware
	IgnoreErrorsFromFirmware bool `json:"ignoreErrorsFromFirmware,omitempty"`

	// ignore identical resends
	IgnoreIdenticalResends bool `json:"ignoreIdenticalResends,omitempty"`

	// log
	Log bool `json:"log,omitempty"`

	// log position on cancel
	LogPositionOnCancel bool `json:"logPositionOnCancel,omitempty"`

	// log position on pause
	LogPositionOnPause bool `json:"logPositionOnPause,omitempty"`

	// long running commands
	LongRunningCommands []string `json:"longRunningCommands"`

	// max timeouts idle
	MaxTimeoutsIdle int64 `json:"maxTimeoutsIdle,omitempty"`

	// max timeouts long
	MaxTimeoutsLong int64 `json:"maxTimeoutsLong,omitempty"`

	// max timeouts printing
	MaxTimeoutsPrinting int64 `json:"maxTimeoutsPrinting,omitempty"`

	// never send checksum
	NeverSendChecksum bool `json:"neverSendChecksum,omitempty"`

	// pausing commands
	PausingCommands []string `json:"pausingCommands"`

	// port
	Port string `json:"port,omitempty"`

	// port options
	PortOptions []string `json:"portOptions"`

	// repetier target temp
	RepetierTargetTemp bool `json:"repetierTargetTemp,omitempty"`

	// sd always available
	SdAlwaysAvailable bool `json:"sdAlwaysAvailable,omitempty"`

	// sd relative path
	SdRelativePath bool `json:"sdRelativePath,omitempty"`

	// support resends without ok
	SupportResendsWithoutOk string `json:"supportResendsWithoutOk,omitempty"`

	// swallow ok after resend
	SwallowOkAfterResend bool `json:"swallowOkAfterResend,omitempty"`

	// timeout baudrate detection pause
	TimeoutBaudrateDetectionPause float64 `json:"timeoutBaudrateDetectionPause,omitempty"`

	// timeout communication
	TimeoutCommunication float64 `json:"timeoutCommunication,omitempty"`

	// timeout communication busy
	TimeoutCommunicationBusy float64 `json:"timeoutCommunicationBusy,omitempty"`

	// timeout connection
	TimeoutConnection float64 `json:"timeoutConnection,omitempty"`

	// timeout detection
	TimeoutDetection float64 `json:"timeoutDetection,omitempty"`

	// timeout position log wait
	TimeoutPositionLogWait float64 `json:"timeoutPositionLogWait,omitempty"`

	// timeout sd status
	TimeoutSdStatus float64 `json:"timeoutSdStatus,omitempty"`

	// timeout sd status autoreport
	TimeoutSdStatusAutoreport float64 `json:"timeoutSdStatusAutoreport,omitempty"`

	// timeout temperature
	TimeoutTemperature float64 `json:"timeoutTemperature,omitempty"`

	// timeout temperature autoreport
	TimeoutTemperatureAutoreport float64 `json:"timeoutTemperatureAutoreport,omitempty"`

	// timeout temperature target set
	TimeoutTemperatureTargetSet float64 `json:"timeoutTemperatureTargetSet,omitempty"`

	// trigger ok for m29
	TriggerOkForM29 bool `json:"triggerOkForM29,omitempty"`

	// wait for start
	WaitForStart bool `json:"waitForStart,omitempty"`
}

// Validate validates this settings serial
func (m *SettingsSerial) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings serial based on context it is used
func (m *SettingsSerial) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsSerial) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsSerial) UnmarshalBinary(b []byte) error {
	var res SettingsSerial
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// SettingsWebcam settings webcam
//
// swagger:model SettingsWebcam
type SettingsWebcam struct {

	// bitrate
	Bitrate string `json:"bitrate,omitempty"`

	// cache buster
	CacheBuster bool `json:"cacheBuster,omitempty"`

	// ffmpeg commandline
	FfmpegCommandline string `json:"ffmpegCommandline,omitempty"`

	// ffmpeg path
	FfmpegPath string `json:"ffmpegPath,omitempty"`

	// ffmpeg threads
	FfmpegThreads int64 `json:"ffmpegThreads,omitempty"`

	// ffmpeg video codec
	FfmpegVideoCodec string `json:"ffmpegVideoCodec,omitempty"`

	// flip h
	FlipH bool `json:"flipH,omitempty"`

	// flip v
	FlipV bool `json:"flipV,omitempty"`

	// rotate90
	Rotate90 bool `json:"rotate90,omitempty"`

	// snapshot ssl validation
	SnapshotSslValidation bool `json:"snapshotSslValidation,omitempty"`

	// snapshot timeout
	SnapshotTimeout int64 `json:"snapshotTimeout,omitempty"`

	// snapshot Url
	SnapshotURL string `json:"snapshotUrl,omitempty"`

	// stream ratio
	StreamRatio string `json:"streamRatio,omitempty"`

	// stream timeout
	StreamTimeout int64 `json:"streamTimeout,omitempty"`

	// stream Url
	StreamURL string `json:"streamUrl,omitempty"`

	// timelapse enabled
	TimelapseEnabled bool `json:"timelapseEnabled,omitempty"`

	// watermark
	Watermark bool `json:"watermark,omitempty"`

	// webcam enabled
	WebcamEnabled bool `json:"webcamEnabled,omitempty"`
}

// Validate validates this settings webcam
func (m *SettingsWebcam) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this settings webcam based on context it is used
func (m *SettingsWebcam) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SettingsWebcam) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SettingsWebcam) UnmarshalBinary(b []byte) error {
	var res SettingsWebcam
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
