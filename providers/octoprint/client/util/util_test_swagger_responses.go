// Code generated by go-swagger; DO NOT EDIT.

package util

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UtilTestReader is a Reader for the UtilTest structure.
type UtilTestReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *UtilTestReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewUtilTestOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("[POST /api/util/test] utilTest", response, response.Code())
	}
}

// NewUtilTestOK creates a UtilTestOK with default headers values
func NewUtilTestOK() *UtilTestOK {
	return &UtilTestOK{}
}

/*
UtilTestOK describes a response with status code 200, with default header values.

Successful operation
*/
type UtilTestOK struct {
	Payload *UtilTestOKBody
}

// IsSuccess returns true when this util test o k response has a 2xx status code
func (o *UtilTestOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this util test o k response has a 3xx status code
func (o *UtilTestOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this util test o k response has a 4xx status code
func (o *UtilTestOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this util test o k response has a 5xx status code
func (o *UtilTestOK) IsServerError() bool {
	return false
}

// IsCode returns true when this util test o k response a status code equal to that given
func (o *UtilTestOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the util test o k response
func (o *UtilTestOK) Code() int {
	return 200
}

func (o *UtilTestOK) Error() string {
	return fmt.Sprintf("[POST /api/util/test][%d] utilTestOK  %+v", 200, o.Payload)
}

func (o *UtilTestOK) String() string {
	return fmt.Sprintf("[POST /api/util/test][%d] utilTestOK  %+v", 200, o.Payload)
}

func (o *UtilTestOK) GetPayload() *UtilTestOKBody {
	return o.Payload
}

func (o *UtilTestOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UtilTestOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
UtilTestBody util test body
swagger:model UtilTestBody
*/
type UtilTestBody struct {

	// command
	// Enum: [path url server resolution address]
	Command string `json:"command,omitempty"`

	// Optional array of unsupported content types. If set and the URL returns a content type included in this list, the test wil fail. E.g. ["video/*"]. Can be used together with content_type_whitelist to further limit broader content type definition, e.g. by putting image/* into the whitelist, but disallowing PNG by including image/png on the blacklist
	ContentTypeBlacklist []string `json:"content_type_blacklist"`

	// content type guess
	ContentTypeGuess bool `json:"content_type_guess,omitempty"`

	// Optional array of supported content types. If set and the URL returns a content type not included in this list, the test will fail. E.g. ["image/*", "text/plain"].
	ContentTypeWhitelist []string `json:"content_type_whitelist"`

	// The request method to use for the test. Optional, defaults to HEAD
	Method string `json:"method,omitempty"`

	// If set to either true, json or bytes, the response body and the response headers from the URL check will be returned as part of the check result as well. json will attempt to parse the response as json and return the parsed result. true or bytes will base64 encode the body and return that
	// Enum: [true json bytes]
	Response string `json:"response,omitempty"`

	// The status code(s) or named status range(s) to test for. Can be either a single value or a list of either HTTP status codes or any of the following named status ranges:
	// Enum: [informational success redirection client_error server_error normal error any]
	Status string `json:"status,omitempty"`

	// A timeout for the request, in seconds. If no reply from the tested URL has been received within this time frame, the check will be considered a failure. Optional, defaults to 3 seconds
	Timeout int64 `json:"timeout,omitempty"`

	// The URL to test. Mandatory
	URL string `json:"url,omitempty"`

	// Whether to validate the SSL connection if the url happens to be an HTTPS URL or not. Optional, defaults to True
	ValidSsl bool `json:"validSsl,omitempty"`
}

// Validate validates this util test body
func (o *UtilTestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommand(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var utilTestBodyTypeCommandPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["path","url","server","resolution","address"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		utilTestBodyTypeCommandPropEnum = append(utilTestBodyTypeCommandPropEnum, v)
	}
}

const (

	// UtilTestBodyCommandPath captures enum value "path"
	UtilTestBodyCommandPath string = "path"

	// UtilTestBodyCommandURL captures enum value "url"
	UtilTestBodyCommandURL string = "url"

	// UtilTestBodyCommandServer captures enum value "server"
	UtilTestBodyCommandServer string = "server"

	// UtilTestBodyCommandResolution captures enum value "resolution"
	UtilTestBodyCommandResolution string = "resolution"

	// UtilTestBodyCommandAddress captures enum value "address"
	UtilTestBodyCommandAddress string = "address"
)

// prop value enum
func (o *UtilTestBody) validateCommandEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, utilTestBodyTypeCommandPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UtilTestBody) validateCommand(formats strfmt.Registry) error {
	if swag.IsZero(o.Command) { // not required
		return nil
	}

	// value enum
	if err := o.validateCommandEnum("body"+"."+"command", "body", o.Command); err != nil {
		return err
	}

	return nil
}

var utilTestBodyTypeResponsePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["true","json","bytes"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		utilTestBodyTypeResponsePropEnum = append(utilTestBodyTypeResponsePropEnum, v)
	}
}

const (

	// UtilTestBodyResponseTrue captures enum value "true"
	UtilTestBodyResponseTrue string = "true"

	// UtilTestBodyResponseJSON captures enum value "json"
	UtilTestBodyResponseJSON string = "json"

	// UtilTestBodyResponseBytes captures enum value "bytes"
	UtilTestBodyResponseBytes string = "bytes"
)

// prop value enum
func (o *UtilTestBody) validateResponseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, utilTestBodyTypeResponsePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UtilTestBody) validateResponse(formats strfmt.Registry) error {
	if swag.IsZero(o.Response) { // not required
		return nil
	}

	// value enum
	if err := o.validateResponseEnum("body"+"."+"response", "body", o.Response); err != nil {
		return err
	}

	return nil
}

var utilTestBodyTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["informational","success","redirection","client_error","server_error","normal","error","any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		utilTestBodyTypeStatusPropEnum = append(utilTestBodyTypeStatusPropEnum, v)
	}
}

const (

	// UtilTestBodyStatusInformational captures enum value "informational"
	UtilTestBodyStatusInformational string = "informational"

	// UtilTestBodyStatusSuccess captures enum value "success"
	UtilTestBodyStatusSuccess string = "success"

	// UtilTestBodyStatusRedirection captures enum value "redirection"
	UtilTestBodyStatusRedirection string = "redirection"

	// UtilTestBodyStatusClientError captures enum value "client_error"
	UtilTestBodyStatusClientError string = "client_error"

	// UtilTestBodyStatusServerError captures enum value "server_error"
	UtilTestBodyStatusServerError string = "server_error"

	// UtilTestBodyStatusNormal captures enum value "normal"
	UtilTestBodyStatusNormal string = "normal"

	// UtilTestBodyStatusError captures enum value "error"
	UtilTestBodyStatusError string = "error"

	// UtilTestBodyStatusAny captures enum value "any"
	UtilTestBodyStatusAny string = "any"
)

// prop value enum
func (o *UtilTestBody) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, utilTestBodyTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (o *UtilTestBody) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	// value enum
	if err := o.validateStatusEnum("body"+"."+"status", "body", o.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this util test body based on context it is used
func (o *UtilTestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UtilTestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UtilTestBody) UnmarshalBinary(b []byte) error {
	var res UtilTestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UtilTestOKBody util test o k body
swagger:model UtilTestOKBody
*/
type UtilTestOKBody struct {

	// headers
	Headers interface{} `json:"headers,omitempty"`

	// response
	Response *UtilTestOKBodyResponse `json:"response,omitempty"`

	// result
	Result bool `json:"result,omitempty"`

	// status
	Status int64 `json:"status,omitempty"`

	// url
	URL string `json:"url,omitempty"`
}

// Validate validates this util test o k body
func (o *UtilTestOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResponse(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UtilTestOKBody) validateResponse(formats strfmt.Registry) error {
	if swag.IsZero(o.Response) { // not required
		return nil
	}

	if o.Response != nil {
		if err := o.Response.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("utilTestOK" + "." + "response")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("utilTestOK" + "." + "response")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this util test o k body based on the context it is used
func (o *UtilTestOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateResponse(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UtilTestOKBody) contextValidateResponse(ctx context.Context, formats strfmt.Registry) error {

	if o.Response != nil {

		if swag.IsZero(o.Response) { // not required
			return nil
		}

		if err := o.Response.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("utilTestOK" + "." + "response")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("utilTestOK" + "." + "response")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UtilTestOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UtilTestOKBody) UnmarshalBinary(b []byte) error {
	var res UtilTestOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UtilTestOKBodyResponse util test o k body response
swagger:model UtilTestOKBodyResponse
*/
type UtilTestOKBodyResponse struct {

	// assumed content type
	AssumedContentType string `json:"assumed_content_type,omitempty"`

	// content
	// Format: byte
	Content strfmt.Base64 `json:"content,omitempty"`
}

// Validate validates this util test o k body response
func (o *UtilTestOKBodyResponse) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this util test o k body response based on context it is used
func (o *UtilTestOKBodyResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UtilTestOKBodyResponse) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UtilTestOKBodyResponse) UnmarshalBinary(b []byte) error {
	var res UtilTestOKBodyResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
