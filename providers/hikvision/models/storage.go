// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Storage storage
//
// swagger:model Storage
type Storage struct {

	// hdd list
	HddList []*StorageHddListItems0 `json:"hddList" xml:"hddList"`

	// nas list
	NasList []*StorageNasListItems0 `json:"nasList" xml:"nasList"`

	// work mode
	// Enum: [group quota extract]
	WorkMode string `json:"workMode,omitempty" xml:"workMode,omitempty"`
}

// Validate validates this storage
func (m *Storage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHddList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNasList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Storage) validateHddList(formats strfmt.Registry) error {
	if swag.IsZero(m.HddList) { // not required
		return nil
	}

	for i := 0; i < len(m.HddList); i++ {
		if swag.IsZero(m.HddList[i]) { // not required
			continue
		}

		if m.HddList[i] != nil {
			if err := m.HddList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hddList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hddList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Storage) validateNasList(formats strfmt.Registry) error {
	if swag.IsZero(m.NasList) { // not required
		return nil
	}

	for i := 0; i < len(m.NasList); i++ {
		if swag.IsZero(m.NasList[i]) { // not required
			continue
		}

		if m.NasList[i] != nil {
			if err := m.NasList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nasList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nasList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var storageTypeWorkModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["group","quota","extract"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageTypeWorkModePropEnum = append(storageTypeWorkModePropEnum, v)
	}
}

const (

	// StorageWorkModeGroup captures enum value "group"
	StorageWorkModeGroup string = "group"

	// StorageWorkModeQuota captures enum value "quota"
	StorageWorkModeQuota string = "quota"

	// StorageWorkModeExtract captures enum value "extract"
	StorageWorkModeExtract string = "extract"
)

// prop value enum
func (m *Storage) validateWorkModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storageTypeWorkModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Storage) validateWorkMode(formats strfmt.Registry) error {
	if swag.IsZero(m.WorkMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateWorkModeEnum("workMode", "body", m.WorkMode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this storage based on the context it is used
func (m *Storage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHddList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNasList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Storage) contextValidateHddList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HddList); i++ {

		if m.HddList[i] != nil {

			if swag.IsZero(m.HddList[i]) { // not required
				return nil
			}

			if err := m.HddList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hddList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hddList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Storage) contextValidateNasList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NasList); i++ {

		if m.NasList[i] != nil {

			if swag.IsZero(m.NasList[i]) { // not required
				return nil
			}

			if err := m.NasList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nasList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nasList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Storage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Storage) UnmarshalBinary(b []byte) error {
	var res Storage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// StorageHddListItems0 storage hdd list items0
//
// swagger:model StorageHddListItems0
type StorageHddListItems0 struct {

	// capacity
	Capacity int64 `json:"capacity,omitempty" xml:"hdd>capacity,omitempty"`

	// free space
	FreeSpace int64 `json:"freeSpace,omitempty" xml:"hdd>freeSpace,omitempty"`

	// group
	Group string `json:"group,omitempty" xml:"hdd>group,omitempty"`

	// id
	ID string `json:"id,omitempty" xml:"hdd>id,omitempty"`

	// name
	Name string `json:"name,omitempty" xml:"hdd>hddName,omitempty"`

	// path
	Path string `json:"path,omitempty" xml:"hdd>hddPath,omitempty"`

	// property
	// Enum: [RW RO Redund]
	Property string `json:"property,omitempty" xml:"hdd>property,omitempty"`

	// status
	Status string `json:"status,omitempty" xml:"hdd>status,omitempty"`

	// type
	Type string `json:"type,omitempty" xml:"hdd>hddType,omitempty"`
}

// Validate validates this storage hdd list items0
func (m *StorageHddListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProperty(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var storageHddListItems0TypePropertyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RW","RO","Redund"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageHddListItems0TypePropertyPropEnum = append(storageHddListItems0TypePropertyPropEnum, v)
	}
}

const (

	// StorageHddListItems0PropertyRW captures enum value "RW"
	StorageHddListItems0PropertyRW string = "RW"

	// StorageHddListItems0PropertyRO captures enum value "RO"
	StorageHddListItems0PropertyRO string = "RO"

	// StorageHddListItems0PropertyRedund captures enum value "Redund"
	StorageHddListItems0PropertyRedund string = "Redund"
)

// prop value enum
func (m *StorageHddListItems0) validatePropertyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storageHddListItems0TypePropertyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StorageHddListItems0) validateProperty(formats strfmt.Registry) error {
	if swag.IsZero(m.Property) { // not required
		return nil
	}

	// value enum
	if err := m.validatePropertyEnum("property", "body", m.Property); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this storage hdd list items0 based on context it is used
func (m *StorageHddListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *StorageHddListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StorageHddListItems0) UnmarshalBinary(b []byte) error {
	var res StorageHddListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// StorageNasListItems0 storage nas list items0
//
// swagger:model StorageNasListItems0
type StorageNasListItems0 struct {

	// addressing format type
	// Enum: [ipaddress hostname]
	AddressingFormatType string `json:"addressingFormatType,omitempty" xml:"nas>addressingFormatType,omitempty"`

	// capacity
	Capacity int64 `json:"capacity,omitempty" xml:"nas>capacity,omitempty"`

	// free space
	FreeSpace int64 `json:"freeSpace,omitempty" xml:"nas>freeSpace,omitempty"`

	// group
	Group string `json:"group,omitempty" xml:"nas>group,omitempty"`

	// host name
	HostName string `json:"hostName,omitempty" xml:"nas>hostName,omitempty"`

	// id
	ID string `json:"id,omitempty" xml:"nas>id,omitempty"`

	// ip address
	IPAddress string `json:"ipAddress,omitempty" xml:"nas>ipAddress,omitempty"`

	// ipv6 address
	IPV6Address string `json:"ipv6Address,omitempty" xml:"nas>ipv6Address,omitempty"`

	// password
	Password string `json:"password,omitempty" xml:"nas>password,omitempty"`

	// path
	Path string `json:"path,omitempty" xml:"nas>path,omitempty"`

	// port no
	PortNo int64 `json:"portNo,omitempty" xml:"nas>portNo,omitempty"`

	// property
	// Enum: [RW RO RDD]
	Property string `json:"property,omitempty" xml:"nas>property,omitempty"`

	// status
	Status string `json:"status,omitempty" xml:"nas>status,omitempty"`

	// type
	Type string `json:"type,omitempty" xml:"nas>nasType,omitempty"`

	// user name
	UserName string `json:"userName,omitempty" xml:"nas>userName,omitempty"`
}

// Validate validates this storage nas list items0
func (m *StorageNasListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddressingFormatType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProperty(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var storageNasListItems0TypeAddressingFormatTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ipaddress","hostname"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageNasListItems0TypeAddressingFormatTypePropEnum = append(storageNasListItems0TypeAddressingFormatTypePropEnum, v)
	}
}

const (

	// StorageNasListItems0AddressingFormatTypeIpaddress captures enum value "ipaddress"
	StorageNasListItems0AddressingFormatTypeIpaddress string = "ipaddress"

	// StorageNasListItems0AddressingFormatTypeHostname captures enum value "hostname"
	StorageNasListItems0AddressingFormatTypeHostname string = "hostname"
)

// prop value enum
func (m *StorageNasListItems0) validateAddressingFormatTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storageNasListItems0TypeAddressingFormatTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StorageNasListItems0) validateAddressingFormatType(formats strfmt.Registry) error {
	if swag.IsZero(m.AddressingFormatType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAddressingFormatTypeEnum("addressingFormatType", "body", m.AddressingFormatType); err != nil {
		return err
	}

	return nil
}

var storageNasListItems0TypePropertyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RW","RO","RDD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageNasListItems0TypePropertyPropEnum = append(storageNasListItems0TypePropertyPropEnum, v)
	}
}

const (

	// StorageNasListItems0PropertyRW captures enum value "RW"
	StorageNasListItems0PropertyRW string = "RW"

	// StorageNasListItems0PropertyRO captures enum value "RO"
	StorageNasListItems0PropertyRO string = "RO"

	// StorageNasListItems0PropertyRDD captures enum value "RDD"
	StorageNasListItems0PropertyRDD string = "RDD"
)

// prop value enum
func (m *StorageNasListItems0) validatePropertyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storageNasListItems0TypePropertyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StorageNasListItems0) validateProperty(formats strfmt.Registry) error {
	if swag.IsZero(m.Property) { // not required
		return nil
	}

	// value enum
	if err := m.validatePropertyEnum("property", "body", m.Property); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this storage nas list items0 based on context it is used
func (m *StorageNasListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *StorageNasListItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StorageNasListItems0) UnmarshalBinary(b []byte) error {
	var res StorageNasListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
